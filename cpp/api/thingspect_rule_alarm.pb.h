// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/thingspect_rule_alarm.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fthingspect_5frule_5falarm_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2fthingspect_5frule_5falarm_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "api/thingspect_device.pb.h"
#include "api/thingspect_status.pb.h"
#include "common/thingspect_datapoint.pb.h"
#include "google/protobuf/empty.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "google/protobuf/field_mask.pb.h"
#include "google/api/annotations.pb.h"
#include "google/api/field_behavior.pb.h"
#include "protoc-gen-openapiv2/options/annotations.pb.h"
#include "validate/validate.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fthingspect_5frule_5falarm_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fthingspect_5frule_5falarm_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_api_2fthingspect_5frule_5falarm_2eproto;
namespace thingspect {
namespace api {
class Alarm;
struct AlarmDefaultTypeInternal;
extern AlarmDefaultTypeInternal _Alarm_default_instance_;
class CreateAlarmRequest;
struct CreateAlarmRequestDefaultTypeInternal;
extern CreateAlarmRequestDefaultTypeInternal _CreateAlarmRequest_default_instance_;
class CreateRuleRequest;
struct CreateRuleRequestDefaultTypeInternal;
extern CreateRuleRequestDefaultTypeInternal _CreateRuleRequest_default_instance_;
class DeleteAlarmRequest;
struct DeleteAlarmRequestDefaultTypeInternal;
extern DeleteAlarmRequestDefaultTypeInternal _DeleteAlarmRequest_default_instance_;
class DeleteRuleRequest;
struct DeleteRuleRequestDefaultTypeInternal;
extern DeleteRuleRequestDefaultTypeInternal _DeleteRuleRequest_default_instance_;
class GetAlarmRequest;
struct GetAlarmRequestDefaultTypeInternal;
extern GetAlarmRequestDefaultTypeInternal _GetAlarmRequest_default_instance_;
class GetRuleRequest;
struct GetRuleRequestDefaultTypeInternal;
extern GetRuleRequestDefaultTypeInternal _GetRuleRequest_default_instance_;
class ListAlarmsRequest;
struct ListAlarmsRequestDefaultTypeInternal;
extern ListAlarmsRequestDefaultTypeInternal _ListAlarmsRequest_default_instance_;
class ListAlarmsResponse;
struct ListAlarmsResponseDefaultTypeInternal;
extern ListAlarmsResponseDefaultTypeInternal _ListAlarmsResponse_default_instance_;
class ListRulesRequest;
struct ListRulesRequestDefaultTypeInternal;
extern ListRulesRequestDefaultTypeInternal _ListRulesRequest_default_instance_;
class ListRulesResponse;
struct ListRulesResponseDefaultTypeInternal;
extern ListRulesResponseDefaultTypeInternal _ListRulesResponse_default_instance_;
class Rule;
struct RuleDefaultTypeInternal;
extern RuleDefaultTypeInternal _Rule_default_instance_;
class TestAlarmRequest;
struct TestAlarmRequestDefaultTypeInternal;
extern TestAlarmRequestDefaultTypeInternal _TestAlarmRequest_default_instance_;
class TestAlarmResponse;
struct TestAlarmResponseDefaultTypeInternal;
extern TestAlarmResponseDefaultTypeInternal _TestAlarmResponse_default_instance_;
class TestRuleRequest;
struct TestRuleRequestDefaultTypeInternal;
extern TestRuleRequestDefaultTypeInternal _TestRuleRequest_default_instance_;
class TestRuleResponse;
struct TestRuleResponseDefaultTypeInternal;
extern TestRuleResponseDefaultTypeInternal _TestRuleResponse_default_instance_;
class UpdateAlarmRequest;
struct UpdateAlarmRequestDefaultTypeInternal;
extern UpdateAlarmRequestDefaultTypeInternal _UpdateAlarmRequest_default_instance_;
class UpdateRuleRequest;
struct UpdateRuleRequestDefaultTypeInternal;
extern UpdateRuleRequestDefaultTypeInternal _UpdateRuleRequest_default_instance_;
}  // namespace api
}  // namespace thingspect
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace thingspect {
namespace api {
enum AlarmType : int {
  ALARM_TYPE_UNSPECIFIED = 0,
  APP = 1,
  SMS = 2,
  EMAIL = 3,
  AlarmType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AlarmType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AlarmType_IsValid(int value);
constexpr AlarmType AlarmType_MIN = static_cast<AlarmType>(0);
constexpr AlarmType AlarmType_MAX = static_cast<AlarmType>(3);
constexpr int AlarmType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
AlarmType_descriptor();
template <typename T>
const std::string& AlarmType_Name(T value) {
  static_assert(std::is_same<T, AlarmType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AlarmType_Name().");
  return AlarmType_Name(static_cast<AlarmType>(value));
}
template <>
inline const std::string& AlarmType_Name(AlarmType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AlarmType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool AlarmType_Parse(absl::string_view name, AlarmType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AlarmType>(
      AlarmType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Rule final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:thingspect.api.Rule) */ {
 public:
  inline Rule() : Rule(nullptr) {}
  ~Rule() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Rule(::google::protobuf::internal::ConstantInitialized);

  Rule(const Rule& from);
  Rule(Rule&& from) noexcept
    : Rule() {
    *this = ::std::move(from);
  }

  inline Rule& operator=(const Rule& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rule& operator=(Rule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rule& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rule* internal_default_instance() {
    return reinterpret_cast<const Rule*>(
               &_Rule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Rule& a, Rule& b) {
    a.Swap(&b);
  }
  inline void Swap(Rule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rule* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rule* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rule>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Rule& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Rule& from) {
    Rule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rule* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "thingspect.api.Rule";
  }
  protected:
  explicit Rule(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kOrgIdFieldNumber = 2,
    kNameFieldNumber = 3,
    kDeviceTagFieldNumber = 5,
    kAttrFieldNumber = 6,
    kExprFieldNumber = 7,
    kCreatedAtFieldNumber = 8,
    kUpdatedAtFieldNumber = 9,
    kStatusFieldNumber = 4,
  };
  // string id = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string org_id = 2 [json_name = "orgID", (.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_org_id() ;
  const std::string& org_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_org_id(Arg_&& arg, Args_... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* ptr);

  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(
      const std::string& value);
  std::string* _internal_mutable_org_id();

  public:
  // string name = 3 [(.validate.rules) = {
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string device_tag = 5 [(.validate.rules) = {
  void clear_device_tag() ;
  const std::string& device_tag() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device_tag(Arg_&& arg, Args_... args);
  std::string* mutable_device_tag();
  PROTOBUF_NODISCARD std::string* release_device_tag();
  void set_allocated_device_tag(std::string* ptr);

  private:
  const std::string& _internal_device_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_tag(
      const std::string& value);
  std::string* _internal_mutable_device_tag();

  public:
  // string attr = 6 [(.validate.rules) = {
  void clear_attr() ;
  const std::string& attr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_attr(Arg_&& arg, Args_... args);
  std::string* mutable_attr();
  PROTOBUF_NODISCARD std::string* release_attr();
  void set_allocated_attr(std::string* ptr);

  private:
  const std::string& _internal_attr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attr(
      const std::string& value);
  std::string* _internal_mutable_attr();

  public:
  // string expr = 7 [(.validate.rules) = {
  void clear_expr() ;
  const std::string& expr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_expr(Arg_&& arg, Args_... args);
  std::string* mutable_expr();
  PROTOBUF_NODISCARD std::string* release_expr();
  void set_allocated_expr(std::string* ptr);

  private:
  const std::string& _internal_expr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expr(
      const std::string& value);
  std::string* _internal_mutable_expr();

  public:
  // .google.protobuf.Timestamp created_at = 8 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_created_at() const;
  void clear_created_at() ;
  const ::google::protobuf::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_created_at();
  ::google::protobuf::Timestamp* mutable_created_at();
  void set_allocated_created_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_created_at();

  private:
  const ::google::protobuf::Timestamp& _internal_created_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_created_at();

  public:
  // .google.protobuf.Timestamp updated_at = 9 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_updated_at() const;
  void clear_updated_at() ;
  const ::google::protobuf::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_updated_at();
  ::google::protobuf::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_updated_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_updated_at();

  private:
  const ::google::protobuf::Timestamp& _internal_updated_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_updated_at();

  public:
  // .thingspect.api.Status status = 4 [(.validate.rules) = {
  void clear_status() ;
  ::thingspect::api::Status status() const;
  void set_status(::thingspect::api::Status value);

  private:
  ::thingspect::api::Status _internal_status() const;
  void _internal_set_status(::thingspect::api::Status value);

  public:
  // @@protoc_insertion_point(class_scope:thingspect.api.Rule)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9, 2, 66, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr org_id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr device_tag_;
    ::google::protobuf::internal::ArenaStringPtr attr_;
    ::google::protobuf::internal::ArenaStringPtr expr_;
    ::google::protobuf::Timestamp* created_at_;
    ::google::protobuf::Timestamp* updated_at_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fthingspect_5frule_5falarm_2eproto;
};// -------------------------------------------------------------------

class CreateRuleRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:thingspect.api.CreateRuleRequest) */ {
 public:
  inline CreateRuleRequest() : CreateRuleRequest(nullptr) {}
  ~CreateRuleRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateRuleRequest(::google::protobuf::internal::ConstantInitialized);

  CreateRuleRequest(const CreateRuleRequest& from);
  CreateRuleRequest(CreateRuleRequest&& from) noexcept
    : CreateRuleRequest() {
    *this = ::std::move(from);
  }

  inline CreateRuleRequest& operator=(const CreateRuleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRuleRequest& operator=(CreateRuleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRuleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRuleRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRuleRequest*>(
               &_CreateRuleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateRuleRequest& a, CreateRuleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRuleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRuleRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRuleRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRuleRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateRuleRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateRuleRequest& from) {
    CreateRuleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRuleRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "thingspect.api.CreateRuleRequest";
  }
  protected:
  explicit CreateRuleRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRuleFieldNumber = 1,
  };
  // .thingspect.api.Rule rule = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_rule() const;
  void clear_rule() ;
  const ::thingspect::api::Rule& rule() const;
  PROTOBUF_NODISCARD ::thingspect::api::Rule* release_rule();
  ::thingspect::api::Rule* mutable_rule();
  void set_allocated_rule(::thingspect::api::Rule* value);
  void unsafe_arena_set_allocated_rule(::thingspect::api::Rule* value);
  ::thingspect::api::Rule* unsafe_arena_release_rule();

  private:
  const ::thingspect::api::Rule& _internal_rule() const;
  ::thingspect::api::Rule* _internal_mutable_rule();

  public:
  // @@protoc_insertion_point(class_scope:thingspect.api.CreateRuleRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::thingspect::api::Rule* rule_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fthingspect_5frule_5falarm_2eproto;
};// -------------------------------------------------------------------

class GetRuleRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:thingspect.api.GetRuleRequest) */ {
 public:
  inline GetRuleRequest() : GetRuleRequest(nullptr) {}
  ~GetRuleRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetRuleRequest(::google::protobuf::internal::ConstantInitialized);

  GetRuleRequest(const GetRuleRequest& from);
  GetRuleRequest(GetRuleRequest&& from) noexcept
    : GetRuleRequest() {
    *this = ::std::move(from);
  }

  inline GetRuleRequest& operator=(const GetRuleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRuleRequest& operator=(GetRuleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRuleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRuleRequest* internal_default_instance() {
    return reinterpret_cast<const GetRuleRequest*>(
               &_GetRuleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetRuleRequest& a, GetRuleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRuleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRuleRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRuleRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRuleRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetRuleRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetRuleRequest& from) {
    GetRuleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRuleRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "thingspect.api.GetRuleRequest";
  }
  protected:
  explicit GetRuleRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:thingspect.api.GetRuleRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 40, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fthingspect_5frule_5falarm_2eproto;
};// -------------------------------------------------------------------

class UpdateRuleRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:thingspect.api.UpdateRuleRequest) */ {
 public:
  inline UpdateRuleRequest() : UpdateRuleRequest(nullptr) {}
  ~UpdateRuleRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateRuleRequest(::google::protobuf::internal::ConstantInitialized);

  UpdateRuleRequest(const UpdateRuleRequest& from);
  UpdateRuleRequest(UpdateRuleRequest&& from) noexcept
    : UpdateRuleRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRuleRequest& operator=(const UpdateRuleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRuleRequest& operator=(UpdateRuleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRuleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRuleRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRuleRequest*>(
               &_UpdateRuleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UpdateRuleRequest& a, UpdateRuleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRuleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRuleRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRuleRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRuleRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateRuleRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateRuleRequest& from) {
    UpdateRuleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRuleRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "thingspect.api.UpdateRuleRequest";
  }
  protected:
  explicit UpdateRuleRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRuleFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
  };
  // .thingspect.api.Rule rule = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_rule() const;
  void clear_rule() ;
  const ::thingspect::api::Rule& rule() const;
  PROTOBUF_NODISCARD ::thingspect::api::Rule* release_rule();
  ::thingspect::api::Rule* mutable_rule();
  void set_allocated_rule(::thingspect::api::Rule* value);
  void unsafe_arena_set_allocated_rule(::thingspect::api::Rule* value);
  ::thingspect::api::Rule* unsafe_arena_release_rule();

  private:
  const ::thingspect::api::Rule& _internal_rule() const;
  ::thingspect::api::Rule* _internal_mutable_rule();

  public:
  // .google.protobuf.FieldMask update_mask = 2;
  bool has_update_mask() const;
  void clear_update_mask() ;
  const ::google::protobuf::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::google::protobuf::FieldMask* release_update_mask();
  ::google::protobuf::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::google::protobuf::FieldMask* value);
  void unsafe_arena_set_allocated_update_mask(::google::protobuf::FieldMask* value);
  ::google::protobuf::FieldMask* unsafe_arena_release_update_mask();

  private:
  const ::google::protobuf::FieldMask& _internal_update_mask() const;
  ::google::protobuf::FieldMask* _internal_mutable_update_mask();

  public:
  // @@protoc_insertion_point(class_scope:thingspect.api.UpdateRuleRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::thingspect::api::Rule* rule_;
    ::google::protobuf::FieldMask* update_mask_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fthingspect_5frule_5falarm_2eproto;
};// -------------------------------------------------------------------

class DeleteRuleRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:thingspect.api.DeleteRuleRequest) */ {
 public:
  inline DeleteRuleRequest() : DeleteRuleRequest(nullptr) {}
  ~DeleteRuleRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteRuleRequest(::google::protobuf::internal::ConstantInitialized);

  DeleteRuleRequest(const DeleteRuleRequest& from);
  DeleteRuleRequest(DeleteRuleRequest&& from) noexcept
    : DeleteRuleRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRuleRequest& operator=(const DeleteRuleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRuleRequest& operator=(DeleteRuleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRuleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRuleRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRuleRequest*>(
               &_DeleteRuleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DeleteRuleRequest& a, DeleteRuleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRuleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRuleRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRuleRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRuleRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteRuleRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DeleteRuleRequest& from) {
    DeleteRuleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRuleRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "thingspect.api.DeleteRuleRequest";
  }
  protected:
  explicit DeleteRuleRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:thingspect.api.DeleteRuleRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 43, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fthingspect_5frule_5falarm_2eproto;
};// -------------------------------------------------------------------

class ListRulesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:thingspect.api.ListRulesRequest) */ {
 public:
  inline ListRulesRequest() : ListRulesRequest(nullptr) {}
  ~ListRulesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListRulesRequest(::google::protobuf::internal::ConstantInitialized);

  ListRulesRequest(const ListRulesRequest& from);
  ListRulesRequest(ListRulesRequest&& from) noexcept
    : ListRulesRequest() {
    *this = ::std::move(from);
  }

  inline ListRulesRequest& operator=(const ListRulesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRulesRequest& operator=(ListRulesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRulesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRulesRequest* internal_default_instance() {
    return reinterpret_cast<const ListRulesRequest*>(
               &_ListRulesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ListRulesRequest& a, ListRulesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRulesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRulesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRulesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRulesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListRulesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListRulesRequest& from) {
    ListRulesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRulesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "thingspect.api.ListRulesRequest";
  }
  protected:
  explicit ListRulesRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageTokenFieldNumber = 2,
    kPageSizeFieldNumber = 1,
  };
  // string page_token = 2;
  void clear_page_token() ;
  const std::string& page_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_page_token(Arg_&& arg, Args_... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* ptr);

  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(
      const std::string& value);
  std::string* _internal_mutable_page_token();

  public:
  // int32 page_size = 1 [(.validate.rules) = {
  void clear_page_size() ;
  ::int32_t page_size() const;
  void set_page_size(::int32_t value);

  private:
  ::int32_t _internal_page_size() const;
  void _internal_set_page_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:thingspect.api.ListRulesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 50, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr page_token_;
    ::int32_t page_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fthingspect_5frule_5falarm_2eproto;
};// -------------------------------------------------------------------

class ListRulesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:thingspect.api.ListRulesResponse) */ {
 public:
  inline ListRulesResponse() : ListRulesResponse(nullptr) {}
  ~ListRulesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListRulesResponse(::google::protobuf::internal::ConstantInitialized);

  ListRulesResponse(const ListRulesResponse& from);
  ListRulesResponse(ListRulesResponse&& from) noexcept
    : ListRulesResponse() {
    *this = ::std::move(from);
  }

  inline ListRulesResponse& operator=(const ListRulesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRulesResponse& operator=(ListRulesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRulesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRulesResponse* internal_default_instance() {
    return reinterpret_cast<const ListRulesResponse*>(
               &_ListRulesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ListRulesResponse& a, ListRulesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRulesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRulesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRulesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRulesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListRulesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListRulesResponse& from) {
    ListRulesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRulesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "thingspect.api.ListRulesResponse";
  }
  protected:
  explicit ListRulesResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRulesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
    kTotalSizeFieldNumber = 3,
  };
  // repeated .thingspect.api.Rule rules = 1;
  int rules_size() const;
  private:
  int _internal_rules_size() const;

  public:
  void clear_rules() ;
  ::thingspect::api::Rule* mutable_rules(int index);
  ::google::protobuf::RepeatedPtrField< ::thingspect::api::Rule >*
      mutable_rules();
  private:
  const ::google::protobuf::RepeatedPtrField<::thingspect::api::Rule>& _internal_rules() const;
  ::google::protobuf::RepeatedPtrField<::thingspect::api::Rule>* _internal_mutable_rules();
  public:
  const ::thingspect::api::Rule& rules(int index) const;
  ::thingspect::api::Rule* add_rules();
  const ::google::protobuf::RepeatedPtrField< ::thingspect::api::Rule >&
      rules() const;
  // string next_page_token = 2;
  void clear_next_page_token() ;
  const std::string& next_page_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_page_token(Arg_&& arg, Args_... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* ptr);

  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(
      const std::string& value);
  std::string* _internal_mutable_next_page_token();

  public:
  // int32 total_size = 3;
  void clear_total_size() ;
  ::int32_t total_size() const;
  void set_total_size(::int32_t value);

  private:
  ::int32_t _internal_total_size() const;
  void _internal_set_total_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:thingspect.api.ListRulesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 56, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::thingspect::api::Rule > rules_;
    ::google::protobuf::internal::ArenaStringPtr next_page_token_;
    ::int32_t total_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fthingspect_5frule_5falarm_2eproto;
};// -------------------------------------------------------------------

class TestRuleRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:thingspect.api.TestRuleRequest) */ {
 public:
  inline TestRuleRequest() : TestRuleRequest(nullptr) {}
  ~TestRuleRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestRuleRequest(::google::protobuf::internal::ConstantInitialized);

  TestRuleRequest(const TestRuleRequest& from);
  TestRuleRequest(TestRuleRequest&& from) noexcept
    : TestRuleRequest() {
    *this = ::std::move(from);
  }

  inline TestRuleRequest& operator=(const TestRuleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestRuleRequest& operator=(TestRuleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestRuleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestRuleRequest* internal_default_instance() {
    return reinterpret_cast<const TestRuleRequest*>(
               &_TestRuleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TestRuleRequest& a, TestRuleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TestRuleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestRuleRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestRuleRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestRuleRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestRuleRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestRuleRequest& from) {
    TestRuleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestRuleRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "thingspect.api.TestRuleRequest";
  }
  protected:
  explicit TestRuleRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
    kRuleFieldNumber = 2,
  };
  // .thingspect.common.DataPoint point = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_point() const;
  void clear_point() ;
  const ::thingspect::common::DataPoint& point() const;
  PROTOBUF_NODISCARD ::thingspect::common::DataPoint* release_point();
  ::thingspect::common::DataPoint* mutable_point();
  void set_allocated_point(::thingspect::common::DataPoint* value);
  void unsafe_arena_set_allocated_point(::thingspect::common::DataPoint* value);
  ::thingspect::common::DataPoint* unsafe_arena_release_point();

  private:
  const ::thingspect::common::DataPoint& _internal_point() const;
  ::thingspect::common::DataPoint* _internal_mutable_point();

  public:
  // .thingspect.api.Rule rule = 2 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_rule() const;
  void clear_rule() ;
  const ::thingspect::api::Rule& rule() const;
  PROTOBUF_NODISCARD ::thingspect::api::Rule* release_rule();
  ::thingspect::api::Rule* mutable_rule();
  void set_allocated_rule(::thingspect::api::Rule* value);
  void unsafe_arena_set_allocated_rule(::thingspect::api::Rule* value);
  ::thingspect::api::Rule* unsafe_arena_release_rule();

  private:
  const ::thingspect::api::Rule& _internal_rule() const;
  ::thingspect::api::Rule* _internal_mutable_rule();

  public:
  // @@protoc_insertion_point(class_scope:thingspect.api.TestRuleRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::thingspect::common::DataPoint* point_;
    ::thingspect::api::Rule* rule_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fthingspect_5frule_5falarm_2eproto;
};// -------------------------------------------------------------------

class TestRuleResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:thingspect.api.TestRuleResponse) */ {
 public:
  inline TestRuleResponse() : TestRuleResponse(nullptr) {}
  ~TestRuleResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestRuleResponse(::google::protobuf::internal::ConstantInitialized);

  TestRuleResponse(const TestRuleResponse& from);
  TestRuleResponse(TestRuleResponse&& from) noexcept
    : TestRuleResponse() {
    *this = ::std::move(from);
  }

  inline TestRuleResponse& operator=(const TestRuleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestRuleResponse& operator=(TestRuleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestRuleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestRuleResponse* internal_default_instance() {
    return reinterpret_cast<const TestRuleResponse*>(
               &_TestRuleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TestRuleResponse& a, TestRuleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TestRuleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestRuleResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestRuleResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestRuleResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestRuleResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestRuleResponse& from) {
    TestRuleResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestRuleResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "thingspect.api.TestRuleResponse";
  }
  protected:
  explicit TestRuleResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // bool result = 1;
  void clear_result() ;
  bool result() const;
  void set_result(bool value);

  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);

  public:
  // @@protoc_insertion_point(class_scope:thingspect.api.TestRuleResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool result_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fthingspect_5frule_5falarm_2eproto;
};// -------------------------------------------------------------------

class Alarm final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:thingspect.api.Alarm) */ {
 public:
  inline Alarm() : Alarm(nullptr) {}
  ~Alarm() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Alarm(::google::protobuf::internal::ConstantInitialized);

  Alarm(const Alarm& from);
  Alarm(Alarm&& from) noexcept
    : Alarm() {
    *this = ::std::move(from);
  }

  inline Alarm& operator=(const Alarm& from) {
    CopyFrom(from);
    return *this;
  }
  inline Alarm& operator=(Alarm&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Alarm& default_instance() {
    return *internal_default_instance();
  }
  static inline const Alarm* internal_default_instance() {
    return reinterpret_cast<const Alarm*>(
               &_Alarm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Alarm& a, Alarm& b) {
    a.Swap(&b);
  }
  inline void Swap(Alarm* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Alarm* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Alarm* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Alarm>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Alarm& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Alarm& from) {
    Alarm::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Alarm* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "thingspect.api.Alarm";
  }
  protected:
  explicit Alarm(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserTagsFieldNumber = 7,
    kIdFieldNumber = 1,
    kOrgIdFieldNumber = 2,
    kRuleIdFieldNumber = 3,
    kNameFieldNumber = 4,
    kSubjectTemplateFieldNumber = 8,
    kBodyTemplateFieldNumber = 9,
    kCreatedAtFieldNumber = 11,
    kUpdatedAtFieldNumber = 12,
    kStatusFieldNumber = 5,
    kTypeFieldNumber = 6,
    kRepeatIntervalFieldNumber = 10,
  };
  // repeated string user_tags = 7 [(.validate.rules) = {
  int user_tags_size() const;
  private:
  int _internal_user_tags_size() const;

  public:
  void clear_user_tags() ;
  const std::string& user_tags(int index) const;
  std::string* mutable_user_tags(int index);
  void set_user_tags(int index, const std::string& value);
  void set_user_tags(int index, std::string&& value);
  void set_user_tags(int index, const char* value);
  void set_user_tags(int index, const char* value, std::size_t size);
  void set_user_tags(int index, absl::string_view value);
  std::string* add_user_tags();
  void add_user_tags(const std::string& value);
  void add_user_tags(std::string&& value);
  void add_user_tags(const char* value);
  void add_user_tags(const char* value, std::size_t size);
  void add_user_tags(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& user_tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_user_tags();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_user_tags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_user_tags();

  public:
  // string id = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string org_id = 2 [json_name = "orgID", (.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_org_id() ;
  const std::string& org_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_org_id(Arg_&& arg, Args_... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* ptr);

  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(
      const std::string& value);
  std::string* _internal_mutable_org_id();

  public:
  // string rule_id = 3 [json_name = "ruleID", (.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_rule_id() ;
  const std::string& rule_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rule_id(Arg_&& arg, Args_... args);
  std::string* mutable_rule_id();
  PROTOBUF_NODISCARD std::string* release_rule_id();
  void set_allocated_rule_id(std::string* ptr);

  private:
  const std::string& _internal_rule_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rule_id(
      const std::string& value);
  std::string* _internal_mutable_rule_id();

  public:
  // string name = 4 [(.validate.rules) = {
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string subject_template = 8 [(.validate.rules) = {
  void clear_subject_template() ;
  const std::string& subject_template() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject_template(Arg_&& arg, Args_... args);
  std::string* mutable_subject_template();
  PROTOBUF_NODISCARD std::string* release_subject_template();
  void set_allocated_subject_template(std::string* ptr);

  private:
  const std::string& _internal_subject_template() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject_template(
      const std::string& value);
  std::string* _internal_mutable_subject_template();

  public:
  // string body_template = 9 [(.validate.rules) = {
  void clear_body_template() ;
  const std::string& body_template() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_body_template(Arg_&& arg, Args_... args);
  std::string* mutable_body_template();
  PROTOBUF_NODISCARD std::string* release_body_template();
  void set_allocated_body_template(std::string* ptr);

  private:
  const std::string& _internal_body_template() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body_template(
      const std::string& value);
  std::string* _internal_mutable_body_template();

  public:
  // .google.protobuf.Timestamp created_at = 11 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_created_at() const;
  void clear_created_at() ;
  const ::google::protobuf::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_created_at();
  ::google::protobuf::Timestamp* mutable_created_at();
  void set_allocated_created_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_created_at();

  private:
  const ::google::protobuf::Timestamp& _internal_created_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_created_at();

  public:
  // .google.protobuf.Timestamp updated_at = 12 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_updated_at() const;
  void clear_updated_at() ;
  const ::google::protobuf::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_updated_at();
  ::google::protobuf::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_updated_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_updated_at();

  private:
  const ::google::protobuf::Timestamp& _internal_updated_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_updated_at();

  public:
  // .thingspect.api.Status status = 5 [(.validate.rules) = {
  void clear_status() ;
  ::thingspect::api::Status status() const;
  void set_status(::thingspect::api::Status value);

  private:
  ::thingspect::api::Status _internal_status() const;
  void _internal_set_status(::thingspect::api::Status value);

  public:
  // .thingspect.api.AlarmType type = 6 [(.validate.rules) = {
  void clear_type() ;
  ::thingspect::api::AlarmType type() const;
  void set_type(::thingspect::api::AlarmType value);

  private:
  ::thingspect::api::AlarmType _internal_type() const;
  void _internal_set_type(::thingspect::api::AlarmType value);

  public:
  // int32 repeat_interval = 10 [(.validate.rules) = {
  void clear_repeat_interval() ;
  ::int32_t repeat_interval() const;
  void set_repeat_interval(::int32_t value);

  private:
  ::int32_t _internal_repeat_interval() const;
  void _internal_set_repeat_interval(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:thingspect.api.Alarm)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 12, 2, 94, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> user_tags_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr org_id_;
    ::google::protobuf::internal::ArenaStringPtr rule_id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr subject_template_;
    ::google::protobuf::internal::ArenaStringPtr body_template_;
    ::google::protobuf::Timestamp* created_at_;
    ::google::protobuf::Timestamp* updated_at_;
    int status_;
    int type_;
    ::int32_t repeat_interval_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fthingspect_5frule_5falarm_2eproto;
};// -------------------------------------------------------------------

class CreateAlarmRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:thingspect.api.CreateAlarmRequest) */ {
 public:
  inline CreateAlarmRequest() : CreateAlarmRequest(nullptr) {}
  ~CreateAlarmRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateAlarmRequest(::google::protobuf::internal::ConstantInitialized);

  CreateAlarmRequest(const CreateAlarmRequest& from);
  CreateAlarmRequest(CreateAlarmRequest&& from) noexcept
    : CreateAlarmRequest() {
    *this = ::std::move(from);
  }

  inline CreateAlarmRequest& operator=(const CreateAlarmRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAlarmRequest& operator=(CreateAlarmRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAlarmRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAlarmRequest* internal_default_instance() {
    return reinterpret_cast<const CreateAlarmRequest*>(
               &_CreateAlarmRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CreateAlarmRequest& a, CreateAlarmRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAlarmRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAlarmRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateAlarmRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateAlarmRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateAlarmRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateAlarmRequest& from) {
    CreateAlarmRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAlarmRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "thingspect.api.CreateAlarmRequest";
  }
  protected:
  explicit CreateAlarmRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlarmFieldNumber = 1,
  };
  // .thingspect.api.Alarm alarm = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_alarm() const;
  void clear_alarm() ;
  const ::thingspect::api::Alarm& alarm() const;
  PROTOBUF_NODISCARD ::thingspect::api::Alarm* release_alarm();
  ::thingspect::api::Alarm* mutable_alarm();
  void set_allocated_alarm(::thingspect::api::Alarm* value);
  void unsafe_arena_set_allocated_alarm(::thingspect::api::Alarm* value);
  ::thingspect::api::Alarm* unsafe_arena_release_alarm();

  private:
  const ::thingspect::api::Alarm& _internal_alarm() const;
  ::thingspect::api::Alarm* _internal_mutable_alarm();

  public:
  // @@protoc_insertion_point(class_scope:thingspect.api.CreateAlarmRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::thingspect::api::Alarm* alarm_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fthingspect_5frule_5falarm_2eproto;
};// -------------------------------------------------------------------

class GetAlarmRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:thingspect.api.GetAlarmRequest) */ {
 public:
  inline GetAlarmRequest() : GetAlarmRequest(nullptr) {}
  ~GetAlarmRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetAlarmRequest(::google::protobuf::internal::ConstantInitialized);

  GetAlarmRequest(const GetAlarmRequest& from);
  GetAlarmRequest(GetAlarmRequest&& from) noexcept
    : GetAlarmRequest() {
    *this = ::std::move(from);
  }

  inline GetAlarmRequest& operator=(const GetAlarmRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAlarmRequest& operator=(GetAlarmRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAlarmRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAlarmRequest* internal_default_instance() {
    return reinterpret_cast<const GetAlarmRequest*>(
               &_GetAlarmRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetAlarmRequest& a, GetAlarmRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAlarmRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAlarmRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAlarmRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAlarmRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetAlarmRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetAlarmRequest& from) {
    GetAlarmRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAlarmRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "thingspect.api.GetAlarmRequest";
  }
  protected:
  explicit GetAlarmRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kRuleIdFieldNumber = 2,
  };
  // string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string rule_id = 2 [json_name = "ruleID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_rule_id() ;
  const std::string& rule_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rule_id(Arg_&& arg, Args_... args);
  std::string* mutable_rule_id();
  PROTOBUF_NODISCARD std::string* release_rule_id();
  void set_allocated_rule_id(std::string* ptr);

  private:
  const std::string& _internal_rule_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rule_id(
      const std::string& value);
  std::string* _internal_mutable_rule_id();

  public:
  // @@protoc_insertion_point(class_scope:thingspect.api.GetAlarmRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 48, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr rule_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fthingspect_5frule_5falarm_2eproto;
};// -------------------------------------------------------------------

class UpdateAlarmRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:thingspect.api.UpdateAlarmRequest) */ {
 public:
  inline UpdateAlarmRequest() : UpdateAlarmRequest(nullptr) {}
  ~UpdateAlarmRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateAlarmRequest(::google::protobuf::internal::ConstantInitialized);

  UpdateAlarmRequest(const UpdateAlarmRequest& from);
  UpdateAlarmRequest(UpdateAlarmRequest&& from) noexcept
    : UpdateAlarmRequest() {
    *this = ::std::move(from);
  }

  inline UpdateAlarmRequest& operator=(const UpdateAlarmRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateAlarmRequest& operator=(UpdateAlarmRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateAlarmRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateAlarmRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateAlarmRequest*>(
               &_UpdateAlarmRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UpdateAlarmRequest& a, UpdateAlarmRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateAlarmRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateAlarmRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateAlarmRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateAlarmRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateAlarmRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateAlarmRequest& from) {
    UpdateAlarmRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateAlarmRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "thingspect.api.UpdateAlarmRequest";
  }
  protected:
  explicit UpdateAlarmRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlarmFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
  };
  // .thingspect.api.Alarm alarm = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_alarm() const;
  void clear_alarm() ;
  const ::thingspect::api::Alarm& alarm() const;
  PROTOBUF_NODISCARD ::thingspect::api::Alarm* release_alarm();
  ::thingspect::api::Alarm* mutable_alarm();
  void set_allocated_alarm(::thingspect::api::Alarm* value);
  void unsafe_arena_set_allocated_alarm(::thingspect::api::Alarm* value);
  ::thingspect::api::Alarm* unsafe_arena_release_alarm();

  private:
  const ::thingspect::api::Alarm& _internal_alarm() const;
  ::thingspect::api::Alarm* _internal_mutable_alarm();

  public:
  // .google.protobuf.FieldMask update_mask = 2;
  bool has_update_mask() const;
  void clear_update_mask() ;
  const ::google::protobuf::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::google::protobuf::FieldMask* release_update_mask();
  ::google::protobuf::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::google::protobuf::FieldMask* value);
  void unsafe_arena_set_allocated_update_mask(::google::protobuf::FieldMask* value);
  ::google::protobuf::FieldMask* unsafe_arena_release_update_mask();

  private:
  const ::google::protobuf::FieldMask& _internal_update_mask() const;
  ::google::protobuf::FieldMask* _internal_mutable_update_mask();

  public:
  // @@protoc_insertion_point(class_scope:thingspect.api.UpdateAlarmRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::thingspect::api::Alarm* alarm_;
    ::google::protobuf::FieldMask* update_mask_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fthingspect_5frule_5falarm_2eproto;
};// -------------------------------------------------------------------

class DeleteAlarmRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:thingspect.api.DeleteAlarmRequest) */ {
 public:
  inline DeleteAlarmRequest() : DeleteAlarmRequest(nullptr) {}
  ~DeleteAlarmRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteAlarmRequest(::google::protobuf::internal::ConstantInitialized);

  DeleteAlarmRequest(const DeleteAlarmRequest& from);
  DeleteAlarmRequest(DeleteAlarmRequest&& from) noexcept
    : DeleteAlarmRequest() {
    *this = ::std::move(from);
  }

  inline DeleteAlarmRequest& operator=(const DeleteAlarmRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteAlarmRequest& operator=(DeleteAlarmRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteAlarmRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteAlarmRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteAlarmRequest*>(
               &_DeleteAlarmRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DeleteAlarmRequest& a, DeleteAlarmRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteAlarmRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteAlarmRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteAlarmRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteAlarmRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteAlarmRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DeleteAlarmRequest& from) {
    DeleteAlarmRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteAlarmRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "thingspect.api.DeleteAlarmRequest";
  }
  protected:
  explicit DeleteAlarmRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kRuleIdFieldNumber = 2,
  };
  // string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string rule_id = 2 [json_name = "ruleID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_rule_id() ;
  const std::string& rule_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rule_id(Arg_&& arg, Args_... args);
  std::string* mutable_rule_id();
  PROTOBUF_NODISCARD std::string* release_rule_id();
  void set_allocated_rule_id(std::string* ptr);

  private:
  const std::string& _internal_rule_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rule_id(
      const std::string& value);
  std::string* _internal_mutable_rule_id();

  public:
  // @@protoc_insertion_point(class_scope:thingspect.api.DeleteAlarmRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 51, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr rule_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fthingspect_5frule_5falarm_2eproto;
};// -------------------------------------------------------------------

class ListAlarmsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:thingspect.api.ListAlarmsRequest) */ {
 public:
  inline ListAlarmsRequest() : ListAlarmsRequest(nullptr) {}
  ~ListAlarmsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListAlarmsRequest(::google::protobuf::internal::ConstantInitialized);

  ListAlarmsRequest(const ListAlarmsRequest& from);
  ListAlarmsRequest(ListAlarmsRequest&& from) noexcept
    : ListAlarmsRequest() {
    *this = ::std::move(from);
  }

  inline ListAlarmsRequest& operator=(const ListAlarmsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAlarmsRequest& operator=(ListAlarmsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAlarmsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAlarmsRequest* internal_default_instance() {
    return reinterpret_cast<const ListAlarmsRequest*>(
               &_ListAlarmsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ListAlarmsRequest& a, ListAlarmsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListAlarmsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAlarmsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAlarmsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListAlarmsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListAlarmsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListAlarmsRequest& from) {
    ListAlarmsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListAlarmsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "thingspect.api.ListAlarmsRequest";
  }
  protected:
  explicit ListAlarmsRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageTokenFieldNumber = 2,
    kRuleIdFieldNumber = 3,
    kPageSizeFieldNumber = 1,
  };
  // string page_token = 2;
  void clear_page_token() ;
  const std::string& page_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_page_token(Arg_&& arg, Args_... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* ptr);

  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(
      const std::string& value);
  std::string* _internal_mutable_page_token();

  public:
  // string rule_id = 3 [json_name = "ruleID", (.validate.rules) = {
  void clear_rule_id() ;
  const std::string& rule_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rule_id(Arg_&& arg, Args_... args);
  std::string* mutable_rule_id();
  PROTOBUF_NODISCARD std::string* release_rule_id();
  void set_allocated_rule_id(std::string* ptr);

  private:
  const std::string& _internal_rule_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rule_id(
      const std::string& value);
  std::string* _internal_mutable_rule_id();

  public:
  // int32 page_size = 1 [(.validate.rules) = {
  void clear_page_size() ;
  ::int32_t page_size() const;
  void set_page_size(::int32_t value);

  private:
  ::int32_t _internal_page_size() const;
  void _internal_set_page_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:thingspect.api.ListAlarmsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 58, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr page_token_;
    ::google::protobuf::internal::ArenaStringPtr rule_id_;
    ::int32_t page_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fthingspect_5frule_5falarm_2eproto;
};// -------------------------------------------------------------------

class ListAlarmsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:thingspect.api.ListAlarmsResponse) */ {
 public:
  inline ListAlarmsResponse() : ListAlarmsResponse(nullptr) {}
  ~ListAlarmsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListAlarmsResponse(::google::protobuf::internal::ConstantInitialized);

  ListAlarmsResponse(const ListAlarmsResponse& from);
  ListAlarmsResponse(ListAlarmsResponse&& from) noexcept
    : ListAlarmsResponse() {
    *this = ::std::move(from);
  }

  inline ListAlarmsResponse& operator=(const ListAlarmsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAlarmsResponse& operator=(ListAlarmsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAlarmsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAlarmsResponse* internal_default_instance() {
    return reinterpret_cast<const ListAlarmsResponse*>(
               &_ListAlarmsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ListAlarmsResponse& a, ListAlarmsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListAlarmsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAlarmsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAlarmsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListAlarmsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListAlarmsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListAlarmsResponse& from) {
    ListAlarmsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListAlarmsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "thingspect.api.ListAlarmsResponse";
  }
  protected:
  explicit ListAlarmsResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlarmsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
    kTotalSizeFieldNumber = 3,
  };
  // repeated .thingspect.api.Alarm alarms = 1;
  int alarms_size() const;
  private:
  int _internal_alarms_size() const;

  public:
  void clear_alarms() ;
  ::thingspect::api::Alarm* mutable_alarms(int index);
  ::google::protobuf::RepeatedPtrField< ::thingspect::api::Alarm >*
      mutable_alarms();
  private:
  const ::google::protobuf::RepeatedPtrField<::thingspect::api::Alarm>& _internal_alarms() const;
  ::google::protobuf::RepeatedPtrField<::thingspect::api::Alarm>* _internal_mutable_alarms();
  public:
  const ::thingspect::api::Alarm& alarms(int index) const;
  ::thingspect::api::Alarm* add_alarms();
  const ::google::protobuf::RepeatedPtrField< ::thingspect::api::Alarm >&
      alarms() const;
  // string next_page_token = 2;
  void clear_next_page_token() ;
  const std::string& next_page_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_page_token(Arg_&& arg, Args_... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* ptr);

  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(
      const std::string& value);
  std::string* _internal_mutable_next_page_token();

  public:
  // int32 total_size = 3;
  void clear_total_size() ;
  ::int32_t total_size() const;
  void set_total_size(::int32_t value);

  private:
  ::int32_t _internal_total_size() const;
  void _internal_set_total_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:thingspect.api.ListAlarmsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 57, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::thingspect::api::Alarm > alarms_;
    ::google::protobuf::internal::ArenaStringPtr next_page_token_;
    ::int32_t total_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fthingspect_5frule_5falarm_2eproto;
};// -------------------------------------------------------------------

class TestAlarmRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:thingspect.api.TestAlarmRequest) */ {
 public:
  inline TestAlarmRequest() : TestAlarmRequest(nullptr) {}
  ~TestAlarmRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestAlarmRequest(::google::protobuf::internal::ConstantInitialized);

  TestAlarmRequest(const TestAlarmRequest& from);
  TestAlarmRequest(TestAlarmRequest&& from) noexcept
    : TestAlarmRequest() {
    *this = ::std::move(from);
  }

  inline TestAlarmRequest& operator=(const TestAlarmRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestAlarmRequest& operator=(TestAlarmRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestAlarmRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestAlarmRequest* internal_default_instance() {
    return reinterpret_cast<const TestAlarmRequest*>(
               &_TestAlarmRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TestAlarmRequest& a, TestAlarmRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TestAlarmRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestAlarmRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestAlarmRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestAlarmRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestAlarmRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestAlarmRequest& from) {
    TestAlarmRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestAlarmRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "thingspect.api.TestAlarmRequest";
  }
  protected:
  explicit TestAlarmRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
    kRuleFieldNumber = 2,
    kDeviceFieldNumber = 3,
    kAlarmFieldNumber = 4,
  };
  // .thingspect.common.DataPoint point = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_point() const;
  void clear_point() ;
  const ::thingspect::common::DataPoint& point() const;
  PROTOBUF_NODISCARD ::thingspect::common::DataPoint* release_point();
  ::thingspect::common::DataPoint* mutable_point();
  void set_allocated_point(::thingspect::common::DataPoint* value);
  void unsafe_arena_set_allocated_point(::thingspect::common::DataPoint* value);
  ::thingspect::common::DataPoint* unsafe_arena_release_point();

  private:
  const ::thingspect::common::DataPoint& _internal_point() const;
  ::thingspect::common::DataPoint* _internal_mutable_point();

  public:
  // .thingspect.api.Rule rule = 2 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_rule() const;
  void clear_rule() ;
  const ::thingspect::api::Rule& rule() const;
  PROTOBUF_NODISCARD ::thingspect::api::Rule* release_rule();
  ::thingspect::api::Rule* mutable_rule();
  void set_allocated_rule(::thingspect::api::Rule* value);
  void unsafe_arena_set_allocated_rule(::thingspect::api::Rule* value);
  ::thingspect::api::Rule* unsafe_arena_release_rule();

  private:
  const ::thingspect::api::Rule& _internal_rule() const;
  ::thingspect::api::Rule* _internal_mutable_rule();

  public:
  // .thingspect.api.Device device = 3 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_device() const;
  void clear_device() ;
  const ::thingspect::api::Device& device() const;
  PROTOBUF_NODISCARD ::thingspect::api::Device* release_device();
  ::thingspect::api::Device* mutable_device();
  void set_allocated_device(::thingspect::api::Device* value);
  void unsafe_arena_set_allocated_device(::thingspect::api::Device* value);
  ::thingspect::api::Device* unsafe_arena_release_device();

  private:
  const ::thingspect::api::Device& _internal_device() const;
  ::thingspect::api::Device* _internal_mutable_device();

  public:
  // .thingspect.api.Alarm alarm = 4 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_alarm() const;
  void clear_alarm() ;
  const ::thingspect::api::Alarm& alarm() const;
  PROTOBUF_NODISCARD ::thingspect::api::Alarm* release_alarm();
  ::thingspect::api::Alarm* mutable_alarm();
  void set_allocated_alarm(::thingspect::api::Alarm* value);
  void unsafe_arena_set_allocated_alarm(::thingspect::api::Alarm* value);
  ::thingspect::api::Alarm* unsafe_arena_release_alarm();

  private:
  const ::thingspect::api::Alarm& _internal_alarm() const;
  ::thingspect::api::Alarm* _internal_mutable_alarm();

  public:
  // @@protoc_insertion_point(class_scope:thingspect.api.TestAlarmRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 4, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::thingspect::common::DataPoint* point_;
    ::thingspect::api::Rule* rule_;
    ::thingspect::api::Device* device_;
    ::thingspect::api::Alarm* alarm_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fthingspect_5frule_5falarm_2eproto;
};// -------------------------------------------------------------------

class TestAlarmResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:thingspect.api.TestAlarmResponse) */ {
 public:
  inline TestAlarmResponse() : TestAlarmResponse(nullptr) {}
  ~TestAlarmResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TestAlarmResponse(::google::protobuf::internal::ConstantInitialized);

  TestAlarmResponse(const TestAlarmResponse& from);
  TestAlarmResponse(TestAlarmResponse&& from) noexcept
    : TestAlarmResponse() {
    *this = ::std::move(from);
  }

  inline TestAlarmResponse& operator=(const TestAlarmResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestAlarmResponse& operator=(TestAlarmResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestAlarmResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestAlarmResponse* internal_default_instance() {
    return reinterpret_cast<const TestAlarmResponse*>(
               &_TestAlarmResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TestAlarmResponse& a, TestAlarmResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TestAlarmResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestAlarmResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestAlarmResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestAlarmResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TestAlarmResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TestAlarmResponse& from) {
    TestAlarmResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestAlarmResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "thingspect.api.TestAlarmResponse";
  }
  protected:
  explicit TestAlarmResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // string result = 1;
  void clear_result() ;
  const std::string& result() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_result(Arg_&& arg, Args_... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* ptr);

  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(
      const std::string& value);
  std::string* _internal_mutable_result();

  public:
  // @@protoc_insertion_point(class_scope:thingspect.api.TestAlarmResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 47, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr result_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fthingspect_5frule_5falarm_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Rule

// string id = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void Rule::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Rule::id() const {
  // @@protoc_insertion_point(field_get:thingspect.api.Rule.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Rule::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.Rule.id)
}
inline std::string* Rule::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:thingspect.api.Rule.id)
  return _s;
}
inline const std::string& Rule::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Rule::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Rule::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Rule::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.Rule.id)
  return _impl_.id_.Release();
}
inline void Rule::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.Rule.id)
}

// string org_id = 2 [json_name = "orgID", (.google.api.field_behavior) = OUTPUT_ONLY];
inline void Rule::clear_org_id() {
  _impl_.org_id_.ClearToEmpty();
}
inline const std::string& Rule::org_id() const {
  // @@protoc_insertion_point(field_get:thingspect.api.Rule.org_id)
  return _internal_org_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Rule::set_org_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.org_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.Rule.org_id)
}
inline std::string* Rule::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:thingspect.api.Rule.org_id)
  return _s;
}
inline const std::string& Rule::_internal_org_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.org_id_.Get();
}
inline void Rule::_internal_set_org_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Rule::_internal_mutable_org_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.org_id_.Mutable( GetArenaForAllocation());
}
inline std::string* Rule::release_org_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.Rule.org_id)
  return _impl_.org_id_.Release();
}
inline void Rule::set_allocated_org_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.org_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.org_id_.IsDefault()) {
          _impl_.org_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.Rule.org_id)
}

// string name = 3 [(.validate.rules) = {
inline void Rule::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Rule::name() const {
  // @@protoc_insertion_point(field_get:thingspect.api.Rule.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Rule::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.Rule.name)
}
inline std::string* Rule::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:thingspect.api.Rule.name)
  return _s;
}
inline const std::string& Rule::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Rule::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Rule::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* Rule::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.Rule.name)
  return _impl_.name_.Release();
}
inline void Rule::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.Rule.name)
}

// .thingspect.api.Status status = 4 [(.validate.rules) = {
inline void Rule::clear_status() {
  _impl_.status_ = 0;
}
inline ::thingspect::api::Status Rule::status() const {
  // @@protoc_insertion_point(field_get:thingspect.api.Rule.status)
  return _internal_status();
}
inline void Rule::set_status(::thingspect::api::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:thingspect.api.Rule.status)
}
inline ::thingspect::api::Status Rule::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::thingspect::api::Status>(_impl_.status_);
}
inline void Rule::_internal_set_status(::thingspect::api::Status value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_ = value;
}

// string device_tag = 5 [(.validate.rules) = {
inline void Rule::clear_device_tag() {
  _impl_.device_tag_.ClearToEmpty();
}
inline const std::string& Rule::device_tag() const {
  // @@protoc_insertion_point(field_get:thingspect.api.Rule.device_tag)
  return _internal_device_tag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Rule::set_device_tag(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_tag_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.Rule.device_tag)
}
inline std::string* Rule::mutable_device_tag() {
  std::string* _s = _internal_mutable_device_tag();
  // @@protoc_insertion_point(field_mutable:thingspect.api.Rule.device_tag)
  return _s;
}
inline const std::string& Rule::_internal_device_tag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_tag_.Get();
}
inline void Rule::_internal_set_device_tag(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_tag_.Set(value, GetArenaForAllocation());
}
inline std::string* Rule::_internal_mutable_device_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_tag_.Mutable( GetArenaForAllocation());
}
inline std::string* Rule::release_device_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.Rule.device_tag)
  return _impl_.device_tag_.Release();
}
inline void Rule::set_allocated_device_tag(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_tag_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_tag_.IsDefault()) {
          _impl_.device_tag_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.Rule.device_tag)
}

// string attr = 6 [(.validate.rules) = {
inline void Rule::clear_attr() {
  _impl_.attr_.ClearToEmpty();
}
inline const std::string& Rule::attr() const {
  // @@protoc_insertion_point(field_get:thingspect.api.Rule.attr)
  return _internal_attr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Rule::set_attr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.attr_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.Rule.attr)
}
inline std::string* Rule::mutable_attr() {
  std::string* _s = _internal_mutable_attr();
  // @@protoc_insertion_point(field_mutable:thingspect.api.Rule.attr)
  return _s;
}
inline const std::string& Rule::_internal_attr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attr_.Get();
}
inline void Rule::_internal_set_attr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.attr_.Set(value, GetArenaForAllocation());
}
inline std::string* Rule::_internal_mutable_attr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.attr_.Mutable( GetArenaForAllocation());
}
inline std::string* Rule::release_attr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.Rule.attr)
  return _impl_.attr_.Release();
}
inline void Rule::set_allocated_attr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.attr_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.attr_.IsDefault()) {
          _impl_.attr_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.Rule.attr)
}

// string expr = 7 [(.validate.rules) = {
inline void Rule::clear_expr() {
  _impl_.expr_.ClearToEmpty();
}
inline const std::string& Rule::expr() const {
  // @@protoc_insertion_point(field_get:thingspect.api.Rule.expr)
  return _internal_expr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Rule::set_expr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.expr_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.Rule.expr)
}
inline std::string* Rule::mutable_expr() {
  std::string* _s = _internal_mutable_expr();
  // @@protoc_insertion_point(field_mutable:thingspect.api.Rule.expr)
  return _s;
}
inline const std::string& Rule::_internal_expr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.expr_.Get();
}
inline void Rule::_internal_set_expr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.expr_.Set(value, GetArenaForAllocation());
}
inline std::string* Rule::_internal_mutable_expr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.expr_.Mutable( GetArenaForAllocation());
}
inline std::string* Rule::release_expr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.Rule.expr)
  return _impl_.expr_.Release();
}
inline void Rule::set_allocated_expr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.expr_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.expr_.IsDefault()) {
          _impl_.expr_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.Rule.expr)
}

// .google.protobuf.Timestamp created_at = 8 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Rule::has_created_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Rule::_internal_created_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Rule::created_at() const {
  // @@protoc_insertion_point(field_get:thingspect.api.Rule.created_at)
  return _internal_created_at();
}
inline void Rule::unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thingspect.api.Rule.created_at)
}
inline ::google::protobuf::Timestamp* Rule::release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Rule::unsafe_arena_release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.Rule.created_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Rule::_internal_mutable_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.created_at_;
}
inline ::google::protobuf::Timestamp* Rule::mutable_created_at() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:thingspect.api.Rule.created_at)
  return _msg;
}
inline void Rule::set_allocated_created_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.Rule.created_at)
}

// .google.protobuf.Timestamp updated_at = 9 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Rule::has_updated_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.updated_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Rule::_internal_updated_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Rule::updated_at() const {
  // @@protoc_insertion_point(field_get:thingspect.api.Rule.updated_at)
  return _internal_updated_at();
}
inline void Rule::unsafe_arena_set_allocated_updated_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thingspect.api.Rule.updated_at)
}
inline ::google::protobuf::Timestamp* Rule::release_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Rule::unsafe_arena_release_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.Rule.updated_at)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Rule::_internal_mutable_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.updated_at_;
}
inline ::google::protobuf::Timestamp* Rule::mutable_updated_at() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:thingspect.api.Rule.updated_at)
  return _msg;
}
inline void Rule::set_allocated_updated_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.Rule.updated_at)
}

// -------------------------------------------------------------------

// CreateRuleRequest

// .thingspect.api.Rule rule = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool CreateRuleRequest::has_rule() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rule_ != nullptr);
  return value;
}
inline void CreateRuleRequest::clear_rule() {
  if (_impl_.rule_ != nullptr) _impl_.rule_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::thingspect::api::Rule& CreateRuleRequest::_internal_rule() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::thingspect::api::Rule* p = _impl_.rule_;
  return p != nullptr ? *p : reinterpret_cast<const ::thingspect::api::Rule&>(::thingspect::api::_Rule_default_instance_);
}
inline const ::thingspect::api::Rule& CreateRuleRequest::rule() const {
  // @@protoc_insertion_point(field_get:thingspect.api.CreateRuleRequest.rule)
  return _internal_rule();
}
inline void CreateRuleRequest::unsafe_arena_set_allocated_rule(::thingspect::api::Rule* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rule_);
  }
  _impl_.rule_ = reinterpret_cast<::thingspect::api::Rule*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thingspect.api.CreateRuleRequest.rule)
}
inline ::thingspect::api::Rule* CreateRuleRequest::release_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thingspect::api::Rule* released = _impl_.rule_;
  _impl_.rule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::thingspect::api::Rule* CreateRuleRequest::unsafe_arena_release_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.CreateRuleRequest.rule)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thingspect::api::Rule* temp = _impl_.rule_;
  _impl_.rule_ = nullptr;
  return temp;
}
inline ::thingspect::api::Rule* CreateRuleRequest::_internal_mutable_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rule_ == nullptr) {
    auto* p = CreateMaybeMessage<::thingspect::api::Rule>(GetArenaForAllocation());
    _impl_.rule_ = reinterpret_cast<::thingspect::api::Rule*>(p);
  }
  return _impl_.rule_;
}
inline ::thingspect::api::Rule* CreateRuleRequest::mutable_rule() {
  ::thingspect::api::Rule* _msg = _internal_mutable_rule();
  // @@protoc_insertion_point(field_mutable:thingspect.api.CreateRuleRequest.rule)
  return _msg;
}
inline void CreateRuleRequest::set_allocated_rule(::thingspect::api::Rule* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::thingspect::api::Rule*>(_impl_.rule_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::thingspect::api::Rule*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.rule_ = reinterpret_cast<::thingspect::api::Rule*>(value);
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.CreateRuleRequest.rule)
}

// -------------------------------------------------------------------

// GetRuleRequest

// string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void GetRuleRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetRuleRequest::id() const {
  // @@protoc_insertion_point(field_get:thingspect.api.GetRuleRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetRuleRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.GetRuleRequest.id)
}
inline std::string* GetRuleRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:thingspect.api.GetRuleRequest.id)
  return _s;
}
inline const std::string& GetRuleRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void GetRuleRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRuleRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* GetRuleRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.GetRuleRequest.id)
  return _impl_.id_.Release();
}
inline void GetRuleRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.GetRuleRequest.id)
}

// -------------------------------------------------------------------

// UpdateRuleRequest

// .thingspect.api.Rule rule = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool UpdateRuleRequest::has_rule() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rule_ != nullptr);
  return value;
}
inline void UpdateRuleRequest::clear_rule() {
  if (_impl_.rule_ != nullptr) _impl_.rule_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::thingspect::api::Rule& UpdateRuleRequest::_internal_rule() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::thingspect::api::Rule* p = _impl_.rule_;
  return p != nullptr ? *p : reinterpret_cast<const ::thingspect::api::Rule&>(::thingspect::api::_Rule_default_instance_);
}
inline const ::thingspect::api::Rule& UpdateRuleRequest::rule() const {
  // @@protoc_insertion_point(field_get:thingspect.api.UpdateRuleRequest.rule)
  return _internal_rule();
}
inline void UpdateRuleRequest::unsafe_arena_set_allocated_rule(::thingspect::api::Rule* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rule_);
  }
  _impl_.rule_ = reinterpret_cast<::thingspect::api::Rule*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thingspect.api.UpdateRuleRequest.rule)
}
inline ::thingspect::api::Rule* UpdateRuleRequest::release_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thingspect::api::Rule* released = _impl_.rule_;
  _impl_.rule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::thingspect::api::Rule* UpdateRuleRequest::unsafe_arena_release_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.UpdateRuleRequest.rule)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thingspect::api::Rule* temp = _impl_.rule_;
  _impl_.rule_ = nullptr;
  return temp;
}
inline ::thingspect::api::Rule* UpdateRuleRequest::_internal_mutable_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rule_ == nullptr) {
    auto* p = CreateMaybeMessage<::thingspect::api::Rule>(GetArenaForAllocation());
    _impl_.rule_ = reinterpret_cast<::thingspect::api::Rule*>(p);
  }
  return _impl_.rule_;
}
inline ::thingspect::api::Rule* UpdateRuleRequest::mutable_rule() {
  ::thingspect::api::Rule* _msg = _internal_mutable_rule();
  // @@protoc_insertion_point(field_mutable:thingspect.api.UpdateRuleRequest.rule)
  return _msg;
}
inline void UpdateRuleRequest::set_allocated_rule(::thingspect::api::Rule* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::thingspect::api::Rule*>(_impl_.rule_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::thingspect::api::Rule*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.rule_ = reinterpret_cast<::thingspect::api::Rule*>(value);
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.UpdateRuleRequest.rule)
}

// .google.protobuf.FieldMask update_mask = 2;
inline bool UpdateRuleRequest::has_update_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.update_mask_ != nullptr);
  return value;
}
inline const ::google::protobuf::FieldMask& UpdateRuleRequest::_internal_update_mask() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::FieldMask&>(::google::protobuf::_FieldMask_default_instance_);
}
inline const ::google::protobuf::FieldMask& UpdateRuleRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:thingspect.api.UpdateRuleRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateRuleRequest::unsafe_arena_set_allocated_update_mask(::google::protobuf::FieldMask* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thingspect.api.UpdateRuleRequest.update_mask)
}
inline ::google::protobuf::FieldMask* UpdateRuleRequest::release_update_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FieldMask* released = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::FieldMask* UpdateRuleRequest::unsafe_arena_release_update_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.UpdateRuleRequest.update_mask)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::google::protobuf::FieldMask* UpdateRuleRequest::_internal_mutable_update_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FieldMask>(GetArenaForAllocation());
    _impl_.update_mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(p);
  }
  return _impl_.update_mask_;
}
inline ::google::protobuf::FieldMask* UpdateRuleRequest::mutable_update_mask() {
  ::google::protobuf::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:thingspect.api.UpdateRuleRequest.update_mask)
  return _msg;
}
inline void UpdateRuleRequest::set_allocated_update_mask(::google::protobuf::FieldMask* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_mask_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.update_mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(value);
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.UpdateRuleRequest.update_mask)
}

// -------------------------------------------------------------------

// DeleteRuleRequest

// string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void DeleteRuleRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& DeleteRuleRequest::id() const {
  // @@protoc_insertion_point(field_get:thingspect.api.DeleteRuleRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteRuleRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.DeleteRuleRequest.id)
}
inline std::string* DeleteRuleRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:thingspect.api.DeleteRuleRequest.id)
  return _s;
}
inline const std::string& DeleteRuleRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void DeleteRuleRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRuleRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* DeleteRuleRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.DeleteRuleRequest.id)
  return _impl_.id_.Release();
}
inline void DeleteRuleRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.DeleteRuleRequest.id)
}

// -------------------------------------------------------------------

// ListRulesRequest

// int32 page_size = 1 [(.validate.rules) = {
inline void ListRulesRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline ::int32_t ListRulesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:thingspect.api.ListRulesRequest.page_size)
  return _internal_page_size();
}
inline void ListRulesRequest::set_page_size(::int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:thingspect.api.ListRulesRequest.page_size)
}
inline ::int32_t ListRulesRequest::_internal_page_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.page_size_;
}
inline void ListRulesRequest::_internal_set_page_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.page_size_ = value;
}

// string page_token = 2;
inline void ListRulesRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListRulesRequest::page_token() const {
  // @@protoc_insertion_point(field_get:thingspect.api.ListRulesRequest.page_token)
  return _internal_page_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListRulesRequest::set_page_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.ListRulesRequest.page_token)
}
inline std::string* ListRulesRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:thingspect.api.ListRulesRequest.page_token)
  return _s;
}
inline const std::string& ListRulesRequest::_internal_page_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.page_token_.Get();
}
inline void ListRulesRequest::_internal_set_page_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListRulesRequest::_internal_mutable_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.page_token_.Mutable( GetArenaForAllocation());
}
inline std::string* ListRulesRequest::release_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.ListRulesRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListRulesRequest::set_allocated_page_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.page_token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.page_token_.IsDefault()) {
          _impl_.page_token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.ListRulesRequest.page_token)
}

// -------------------------------------------------------------------

// ListRulesResponse

// repeated .thingspect.api.Rule rules = 1;
inline int ListRulesResponse::_internal_rules_size() const {
  return _internal_rules().size();
}
inline int ListRulesResponse::rules_size() const {
  return _internal_rules_size();
}
inline void ListRulesResponse::clear_rules() {
  _internal_mutable_rules()->Clear();
}
inline ::thingspect::api::Rule* ListRulesResponse::mutable_rules(int index) {
  // @@protoc_insertion_point(field_mutable:thingspect.api.ListRulesResponse.rules)
  return _internal_mutable_rules()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::thingspect::api::Rule >*
ListRulesResponse::mutable_rules() {
  // @@protoc_insertion_point(field_mutable_list:thingspect.api.ListRulesResponse.rules)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_rules();
}
inline const ::thingspect::api::Rule& ListRulesResponse::rules(int index) const {
  // @@protoc_insertion_point(field_get:thingspect.api.ListRulesResponse.rules)
    return _internal_rules().Get(index);
}
inline ::thingspect::api::Rule* ListRulesResponse::add_rules() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::thingspect::api::Rule* _add = _internal_mutable_rules()->Add();
  // @@protoc_insertion_point(field_add:thingspect.api.ListRulesResponse.rules)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::thingspect::api::Rule >&
ListRulesResponse::rules() const {
  // @@protoc_insertion_point(field_list:thingspect.api.ListRulesResponse.rules)
  return _internal_rules();
}
inline const ::google::protobuf::RepeatedPtrField<::thingspect::api::Rule>&
ListRulesResponse::_internal_rules() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rules_;
}
inline ::google::protobuf::RepeatedPtrField<::thingspect::api::Rule>*
ListRulesResponse::_internal_mutable_rules() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.rules_;
}

// string next_page_token = 2;
inline void ListRulesResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListRulesResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:thingspect.api.ListRulesResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListRulesResponse::set_next_page_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.next_page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.ListRulesResponse.next_page_token)
}
inline std::string* ListRulesResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:thingspect.api.ListRulesResponse.next_page_token)
  return _s;
}
inline const std::string& ListRulesResponse::_internal_next_page_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.next_page_token_.Get();
}
inline void ListRulesResponse::_internal_set_next_page_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListRulesResponse::_internal_mutable_next_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.next_page_token_.Mutable( GetArenaForAllocation());
}
inline std::string* ListRulesResponse::release_next_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.ListRulesResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListRulesResponse::set_allocated_next_page_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.next_page_token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.next_page_token_.IsDefault()) {
          _impl_.next_page_token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.ListRulesResponse.next_page_token)
}

// int32 total_size = 3;
inline void ListRulesResponse::clear_total_size() {
  _impl_.total_size_ = 0;
}
inline ::int32_t ListRulesResponse::total_size() const {
  // @@protoc_insertion_point(field_get:thingspect.api.ListRulesResponse.total_size)
  return _internal_total_size();
}
inline void ListRulesResponse::set_total_size(::int32_t value) {
  _internal_set_total_size(value);
  // @@protoc_insertion_point(field_set:thingspect.api.ListRulesResponse.total_size)
}
inline ::int32_t ListRulesResponse::_internal_total_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_size_;
}
inline void ListRulesResponse::_internal_set_total_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_size_ = value;
}

// -------------------------------------------------------------------

// TestRuleRequest

// .thingspect.common.DataPoint point = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool TestRuleRequest::has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point_ != nullptr);
  return value;
}
inline const ::thingspect::common::DataPoint& TestRuleRequest::_internal_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::thingspect::common::DataPoint* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::thingspect::common::DataPoint&>(::thingspect::common::_DataPoint_default_instance_);
}
inline const ::thingspect::common::DataPoint& TestRuleRequest::point() const {
  // @@protoc_insertion_point(field_get:thingspect.api.TestRuleRequest.point)
  return _internal_point();
}
inline void TestRuleRequest::unsafe_arena_set_allocated_point(::thingspect::common::DataPoint* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = reinterpret_cast<::thingspect::common::DataPoint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thingspect.api.TestRuleRequest.point)
}
inline ::thingspect::common::DataPoint* TestRuleRequest::release_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thingspect::common::DataPoint* released = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::thingspect::common::DataPoint* TestRuleRequest::unsafe_arena_release_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.TestRuleRequest.point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thingspect::common::DataPoint* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::thingspect::common::DataPoint* TestRuleRequest::_internal_mutable_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::thingspect::common::DataPoint>(GetArenaForAllocation());
    _impl_.point_ = reinterpret_cast<::thingspect::common::DataPoint*>(p);
  }
  return _impl_.point_;
}
inline ::thingspect::common::DataPoint* TestRuleRequest::mutable_point() {
  ::thingspect::common::DataPoint* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:thingspect.api.TestRuleRequest.point)
  return _msg;
}
inline void TestRuleRequest::set_allocated_point(::thingspect::common::DataPoint* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.point_ = reinterpret_cast<::thingspect::common::DataPoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.TestRuleRequest.point)
}

// .thingspect.api.Rule rule = 2 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool TestRuleRequest::has_rule() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rule_ != nullptr);
  return value;
}
inline void TestRuleRequest::clear_rule() {
  if (_impl_.rule_ != nullptr) _impl_.rule_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::thingspect::api::Rule& TestRuleRequest::_internal_rule() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::thingspect::api::Rule* p = _impl_.rule_;
  return p != nullptr ? *p : reinterpret_cast<const ::thingspect::api::Rule&>(::thingspect::api::_Rule_default_instance_);
}
inline const ::thingspect::api::Rule& TestRuleRequest::rule() const {
  // @@protoc_insertion_point(field_get:thingspect.api.TestRuleRequest.rule)
  return _internal_rule();
}
inline void TestRuleRequest::unsafe_arena_set_allocated_rule(::thingspect::api::Rule* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rule_);
  }
  _impl_.rule_ = reinterpret_cast<::thingspect::api::Rule*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thingspect.api.TestRuleRequest.rule)
}
inline ::thingspect::api::Rule* TestRuleRequest::release_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::thingspect::api::Rule* released = _impl_.rule_;
  _impl_.rule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::thingspect::api::Rule* TestRuleRequest::unsafe_arena_release_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.TestRuleRequest.rule)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::thingspect::api::Rule* temp = _impl_.rule_;
  _impl_.rule_ = nullptr;
  return temp;
}
inline ::thingspect::api::Rule* TestRuleRequest::_internal_mutable_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.rule_ == nullptr) {
    auto* p = CreateMaybeMessage<::thingspect::api::Rule>(GetArenaForAllocation());
    _impl_.rule_ = reinterpret_cast<::thingspect::api::Rule*>(p);
  }
  return _impl_.rule_;
}
inline ::thingspect::api::Rule* TestRuleRequest::mutable_rule() {
  ::thingspect::api::Rule* _msg = _internal_mutable_rule();
  // @@protoc_insertion_point(field_mutable:thingspect.api.TestRuleRequest.rule)
  return _msg;
}
inline void TestRuleRequest::set_allocated_rule(::thingspect::api::Rule* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::thingspect::api::Rule*>(_impl_.rule_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::thingspect::api::Rule*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rule_ = reinterpret_cast<::thingspect::api::Rule*>(value);
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.TestRuleRequest.rule)
}

// -------------------------------------------------------------------

// TestRuleResponse

// bool result = 1;
inline void TestRuleResponse::clear_result() {
  _impl_.result_ = false;
}
inline bool TestRuleResponse::result() const {
  // @@protoc_insertion_point(field_get:thingspect.api.TestRuleResponse.result)
  return _internal_result();
}
inline void TestRuleResponse::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:thingspect.api.TestRuleResponse.result)
}
inline bool TestRuleResponse::_internal_result() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.result_;
}
inline void TestRuleResponse::_internal_set_result(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.result_ = value;
}

// -------------------------------------------------------------------

// Alarm

// string id = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void Alarm::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Alarm::id() const {
  // @@protoc_insertion_point(field_get:thingspect.api.Alarm.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Alarm::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.Alarm.id)
}
inline std::string* Alarm::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:thingspect.api.Alarm.id)
  return _s;
}
inline const std::string& Alarm::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Alarm::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Alarm::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Alarm::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.Alarm.id)
  return _impl_.id_.Release();
}
inline void Alarm::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.Alarm.id)
}

// string org_id = 2 [json_name = "orgID", (.google.api.field_behavior) = OUTPUT_ONLY];
inline void Alarm::clear_org_id() {
  _impl_.org_id_.ClearToEmpty();
}
inline const std::string& Alarm::org_id() const {
  // @@protoc_insertion_point(field_get:thingspect.api.Alarm.org_id)
  return _internal_org_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Alarm::set_org_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.org_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.Alarm.org_id)
}
inline std::string* Alarm::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:thingspect.api.Alarm.org_id)
  return _s;
}
inline const std::string& Alarm::_internal_org_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.org_id_.Get();
}
inline void Alarm::_internal_set_org_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Alarm::_internal_mutable_org_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.org_id_.Mutable( GetArenaForAllocation());
}
inline std::string* Alarm::release_org_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.Alarm.org_id)
  return _impl_.org_id_.Release();
}
inline void Alarm::set_allocated_org_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.org_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.org_id_.IsDefault()) {
          _impl_.org_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.Alarm.org_id)
}

// string rule_id = 3 [json_name = "ruleID", (.google.api.field_behavior) = OUTPUT_ONLY];
inline void Alarm::clear_rule_id() {
  _impl_.rule_id_.ClearToEmpty();
}
inline const std::string& Alarm::rule_id() const {
  // @@protoc_insertion_point(field_get:thingspect.api.Alarm.rule_id)
  return _internal_rule_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Alarm::set_rule_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rule_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.Alarm.rule_id)
}
inline std::string* Alarm::mutable_rule_id() {
  std::string* _s = _internal_mutable_rule_id();
  // @@protoc_insertion_point(field_mutable:thingspect.api.Alarm.rule_id)
  return _s;
}
inline const std::string& Alarm::_internal_rule_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rule_id_.Get();
}
inline void Alarm::_internal_set_rule_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rule_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Alarm::_internal_mutable_rule_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.rule_id_.Mutable( GetArenaForAllocation());
}
inline std::string* Alarm::release_rule_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.Alarm.rule_id)
  return _impl_.rule_id_.Release();
}
inline void Alarm::set_allocated_rule_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rule_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rule_id_.IsDefault()) {
          _impl_.rule_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.Alarm.rule_id)
}

// string name = 4 [(.validate.rules) = {
inline void Alarm::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Alarm::name() const {
  // @@protoc_insertion_point(field_get:thingspect.api.Alarm.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Alarm::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.Alarm.name)
}
inline std::string* Alarm::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:thingspect.api.Alarm.name)
  return _s;
}
inline const std::string& Alarm::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Alarm::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Alarm::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* Alarm::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.Alarm.name)
  return _impl_.name_.Release();
}
inline void Alarm::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.Alarm.name)
}

// .thingspect.api.Status status = 5 [(.validate.rules) = {
inline void Alarm::clear_status() {
  _impl_.status_ = 0;
}
inline ::thingspect::api::Status Alarm::status() const {
  // @@protoc_insertion_point(field_get:thingspect.api.Alarm.status)
  return _internal_status();
}
inline void Alarm::set_status(::thingspect::api::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:thingspect.api.Alarm.status)
}
inline ::thingspect::api::Status Alarm::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::thingspect::api::Status>(_impl_.status_);
}
inline void Alarm::_internal_set_status(::thingspect::api::Status value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_ = value;
}

// .thingspect.api.AlarmType type = 6 [(.validate.rules) = {
inline void Alarm::clear_type() {
  _impl_.type_ = 0;
}
inline ::thingspect::api::AlarmType Alarm::type() const {
  // @@protoc_insertion_point(field_get:thingspect.api.Alarm.type)
  return _internal_type();
}
inline void Alarm::set_type(::thingspect::api::AlarmType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:thingspect.api.Alarm.type)
}
inline ::thingspect::api::AlarmType Alarm::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::thingspect::api::AlarmType>(_impl_.type_);
}
inline void Alarm::_internal_set_type(::thingspect::api::AlarmType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// repeated string user_tags = 7 [(.validate.rules) = {
inline int Alarm::_internal_user_tags_size() const {
  return _internal_user_tags().size();
}
inline int Alarm::user_tags_size() const {
  return _internal_user_tags_size();
}
inline void Alarm::clear_user_tags() {
  _internal_mutable_user_tags()->Clear();
}
inline std::string* Alarm::add_user_tags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_user_tags()->Add();
  // @@protoc_insertion_point(field_add_mutable:thingspect.api.Alarm.user_tags)
  return _s;
}
inline const std::string& Alarm::user_tags(int index) const {
  // @@protoc_insertion_point(field_get:thingspect.api.Alarm.user_tags)
  return _internal_user_tags().Get(index);
}
inline std::string* Alarm::mutable_user_tags(int index) {
  // @@protoc_insertion_point(field_mutable:thingspect.api.Alarm.user_tags)
  return _internal_mutable_user_tags()->Mutable(index);
}
inline void Alarm::set_user_tags(int index, const std::string& value) {
  _internal_mutable_user_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:thingspect.api.Alarm.user_tags)
}
inline void Alarm::set_user_tags(int index, std::string&& value) {
  _internal_mutable_user_tags()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:thingspect.api.Alarm.user_tags)
}
inline void Alarm::set_user_tags(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_user_tags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:thingspect.api.Alarm.user_tags)
}
inline void Alarm::set_user_tags(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_user_tags()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:thingspect.api.Alarm.user_tags)
}
inline void Alarm::set_user_tags(int index, absl::string_view value) {
  _internal_mutable_user_tags()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:thingspect.api.Alarm.user_tags)
}
inline void Alarm::add_user_tags(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_user_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:thingspect.api.Alarm.user_tags)
}
inline void Alarm::add_user_tags(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_user_tags()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:thingspect.api.Alarm.user_tags)
}
inline void Alarm::add_user_tags(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_user_tags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:thingspect.api.Alarm.user_tags)
}
inline void Alarm::add_user_tags(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_user_tags()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:thingspect.api.Alarm.user_tags)
}
inline void Alarm::add_user_tags(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_user_tags()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:thingspect.api.Alarm.user_tags)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Alarm::user_tags() const {
  // @@protoc_insertion_point(field_list:thingspect.api.Alarm.user_tags)
  return _internal_user_tags();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* Alarm::mutable_user_tags() {
  // @@protoc_insertion_point(field_mutable_list:thingspect.api.Alarm.user_tags)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_user_tags();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Alarm::_internal_user_tags() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_tags_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Alarm::_internal_mutable_user_tags() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.user_tags_;
}

// string subject_template = 8 [(.validate.rules) = {
inline void Alarm::clear_subject_template() {
  _impl_.subject_template_.ClearToEmpty();
}
inline const std::string& Alarm::subject_template() const {
  // @@protoc_insertion_point(field_get:thingspect.api.Alarm.subject_template)
  return _internal_subject_template();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Alarm::set_subject_template(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.subject_template_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.Alarm.subject_template)
}
inline std::string* Alarm::mutable_subject_template() {
  std::string* _s = _internal_mutable_subject_template();
  // @@protoc_insertion_point(field_mutable:thingspect.api.Alarm.subject_template)
  return _s;
}
inline const std::string& Alarm::_internal_subject_template() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subject_template_.Get();
}
inline void Alarm::_internal_set_subject_template(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.subject_template_.Set(value, GetArenaForAllocation());
}
inline std::string* Alarm::_internal_mutable_subject_template() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.subject_template_.Mutable( GetArenaForAllocation());
}
inline std::string* Alarm::release_subject_template() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.Alarm.subject_template)
  return _impl_.subject_template_.Release();
}
inline void Alarm::set_allocated_subject_template(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subject_template_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subject_template_.IsDefault()) {
          _impl_.subject_template_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.Alarm.subject_template)
}

// string body_template = 9 [(.validate.rules) = {
inline void Alarm::clear_body_template() {
  _impl_.body_template_.ClearToEmpty();
}
inline const std::string& Alarm::body_template() const {
  // @@protoc_insertion_point(field_get:thingspect.api.Alarm.body_template)
  return _internal_body_template();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Alarm::set_body_template(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.body_template_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.Alarm.body_template)
}
inline std::string* Alarm::mutable_body_template() {
  std::string* _s = _internal_mutable_body_template();
  // @@protoc_insertion_point(field_mutable:thingspect.api.Alarm.body_template)
  return _s;
}
inline const std::string& Alarm::_internal_body_template() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.body_template_.Get();
}
inline void Alarm::_internal_set_body_template(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.body_template_.Set(value, GetArenaForAllocation());
}
inline std::string* Alarm::_internal_mutable_body_template() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.body_template_.Mutable( GetArenaForAllocation());
}
inline std::string* Alarm::release_body_template() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.Alarm.body_template)
  return _impl_.body_template_.Release();
}
inline void Alarm::set_allocated_body_template(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.body_template_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.body_template_.IsDefault()) {
          _impl_.body_template_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.Alarm.body_template)
}

// int32 repeat_interval = 10 [(.validate.rules) = {
inline void Alarm::clear_repeat_interval() {
  _impl_.repeat_interval_ = 0;
}
inline ::int32_t Alarm::repeat_interval() const {
  // @@protoc_insertion_point(field_get:thingspect.api.Alarm.repeat_interval)
  return _internal_repeat_interval();
}
inline void Alarm::set_repeat_interval(::int32_t value) {
  _internal_set_repeat_interval(value);
  // @@protoc_insertion_point(field_set:thingspect.api.Alarm.repeat_interval)
}
inline ::int32_t Alarm::_internal_repeat_interval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.repeat_interval_;
}
inline void Alarm::_internal_set_repeat_interval(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.repeat_interval_ = value;
}

// .google.protobuf.Timestamp created_at = 11 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Alarm::has_created_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Alarm::_internal_created_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Alarm::created_at() const {
  // @@protoc_insertion_point(field_get:thingspect.api.Alarm.created_at)
  return _internal_created_at();
}
inline void Alarm::unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thingspect.api.Alarm.created_at)
}
inline ::google::protobuf::Timestamp* Alarm::release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Alarm::unsafe_arena_release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.Alarm.created_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Alarm::_internal_mutable_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.created_at_;
}
inline ::google::protobuf::Timestamp* Alarm::mutable_created_at() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:thingspect.api.Alarm.created_at)
  return _msg;
}
inline void Alarm::set_allocated_created_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.Alarm.created_at)
}

// .google.protobuf.Timestamp updated_at = 12 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Alarm::has_updated_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.updated_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Alarm::_internal_updated_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Alarm::updated_at() const {
  // @@protoc_insertion_point(field_get:thingspect.api.Alarm.updated_at)
  return _internal_updated_at();
}
inline void Alarm::unsafe_arena_set_allocated_updated_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thingspect.api.Alarm.updated_at)
}
inline ::google::protobuf::Timestamp* Alarm::release_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Alarm::unsafe_arena_release_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.Alarm.updated_at)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Alarm::_internal_mutable_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.updated_at_;
}
inline ::google::protobuf::Timestamp* Alarm::mutable_updated_at() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:thingspect.api.Alarm.updated_at)
  return _msg;
}
inline void Alarm::set_allocated_updated_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.Alarm.updated_at)
}

// -------------------------------------------------------------------

// CreateAlarmRequest

// .thingspect.api.Alarm alarm = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool CreateAlarmRequest::has_alarm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.alarm_ != nullptr);
  return value;
}
inline void CreateAlarmRequest::clear_alarm() {
  if (_impl_.alarm_ != nullptr) _impl_.alarm_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::thingspect::api::Alarm& CreateAlarmRequest::_internal_alarm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::thingspect::api::Alarm* p = _impl_.alarm_;
  return p != nullptr ? *p : reinterpret_cast<const ::thingspect::api::Alarm&>(::thingspect::api::_Alarm_default_instance_);
}
inline const ::thingspect::api::Alarm& CreateAlarmRequest::alarm() const {
  // @@protoc_insertion_point(field_get:thingspect.api.CreateAlarmRequest.alarm)
  return _internal_alarm();
}
inline void CreateAlarmRequest::unsafe_arena_set_allocated_alarm(::thingspect::api::Alarm* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.alarm_);
  }
  _impl_.alarm_ = reinterpret_cast<::thingspect::api::Alarm*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thingspect.api.CreateAlarmRequest.alarm)
}
inline ::thingspect::api::Alarm* CreateAlarmRequest::release_alarm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thingspect::api::Alarm* released = _impl_.alarm_;
  _impl_.alarm_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::thingspect::api::Alarm* CreateAlarmRequest::unsafe_arena_release_alarm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.CreateAlarmRequest.alarm)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thingspect::api::Alarm* temp = _impl_.alarm_;
  _impl_.alarm_ = nullptr;
  return temp;
}
inline ::thingspect::api::Alarm* CreateAlarmRequest::_internal_mutable_alarm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.alarm_ == nullptr) {
    auto* p = CreateMaybeMessage<::thingspect::api::Alarm>(GetArenaForAllocation());
    _impl_.alarm_ = reinterpret_cast<::thingspect::api::Alarm*>(p);
  }
  return _impl_.alarm_;
}
inline ::thingspect::api::Alarm* CreateAlarmRequest::mutable_alarm() {
  ::thingspect::api::Alarm* _msg = _internal_mutable_alarm();
  // @@protoc_insertion_point(field_mutable:thingspect.api.CreateAlarmRequest.alarm)
  return _msg;
}
inline void CreateAlarmRequest::set_allocated_alarm(::thingspect::api::Alarm* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::thingspect::api::Alarm*>(_impl_.alarm_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::thingspect::api::Alarm*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.alarm_ = reinterpret_cast<::thingspect::api::Alarm*>(value);
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.CreateAlarmRequest.alarm)
}

// -------------------------------------------------------------------

// GetAlarmRequest

// string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void GetAlarmRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetAlarmRequest::id() const {
  // @@protoc_insertion_point(field_get:thingspect.api.GetAlarmRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetAlarmRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.GetAlarmRequest.id)
}
inline std::string* GetAlarmRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:thingspect.api.GetAlarmRequest.id)
  return _s;
}
inline const std::string& GetAlarmRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void GetAlarmRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAlarmRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* GetAlarmRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.GetAlarmRequest.id)
  return _impl_.id_.Release();
}
inline void GetAlarmRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.GetAlarmRequest.id)
}

// string rule_id = 2 [json_name = "ruleID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void GetAlarmRequest::clear_rule_id() {
  _impl_.rule_id_.ClearToEmpty();
}
inline const std::string& GetAlarmRequest::rule_id() const {
  // @@protoc_insertion_point(field_get:thingspect.api.GetAlarmRequest.rule_id)
  return _internal_rule_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetAlarmRequest::set_rule_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rule_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.GetAlarmRequest.rule_id)
}
inline std::string* GetAlarmRequest::mutable_rule_id() {
  std::string* _s = _internal_mutable_rule_id();
  // @@protoc_insertion_point(field_mutable:thingspect.api.GetAlarmRequest.rule_id)
  return _s;
}
inline const std::string& GetAlarmRequest::_internal_rule_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rule_id_.Get();
}
inline void GetAlarmRequest::_internal_set_rule_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rule_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAlarmRequest::_internal_mutable_rule_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.rule_id_.Mutable( GetArenaForAllocation());
}
inline std::string* GetAlarmRequest::release_rule_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.GetAlarmRequest.rule_id)
  return _impl_.rule_id_.Release();
}
inline void GetAlarmRequest::set_allocated_rule_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rule_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rule_id_.IsDefault()) {
          _impl_.rule_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.GetAlarmRequest.rule_id)
}

// -------------------------------------------------------------------

// UpdateAlarmRequest

// .thingspect.api.Alarm alarm = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool UpdateAlarmRequest::has_alarm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.alarm_ != nullptr);
  return value;
}
inline void UpdateAlarmRequest::clear_alarm() {
  if (_impl_.alarm_ != nullptr) _impl_.alarm_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::thingspect::api::Alarm& UpdateAlarmRequest::_internal_alarm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::thingspect::api::Alarm* p = _impl_.alarm_;
  return p != nullptr ? *p : reinterpret_cast<const ::thingspect::api::Alarm&>(::thingspect::api::_Alarm_default_instance_);
}
inline const ::thingspect::api::Alarm& UpdateAlarmRequest::alarm() const {
  // @@protoc_insertion_point(field_get:thingspect.api.UpdateAlarmRequest.alarm)
  return _internal_alarm();
}
inline void UpdateAlarmRequest::unsafe_arena_set_allocated_alarm(::thingspect::api::Alarm* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.alarm_);
  }
  _impl_.alarm_ = reinterpret_cast<::thingspect::api::Alarm*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thingspect.api.UpdateAlarmRequest.alarm)
}
inline ::thingspect::api::Alarm* UpdateAlarmRequest::release_alarm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thingspect::api::Alarm* released = _impl_.alarm_;
  _impl_.alarm_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::thingspect::api::Alarm* UpdateAlarmRequest::unsafe_arena_release_alarm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.UpdateAlarmRequest.alarm)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thingspect::api::Alarm* temp = _impl_.alarm_;
  _impl_.alarm_ = nullptr;
  return temp;
}
inline ::thingspect::api::Alarm* UpdateAlarmRequest::_internal_mutable_alarm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.alarm_ == nullptr) {
    auto* p = CreateMaybeMessage<::thingspect::api::Alarm>(GetArenaForAllocation());
    _impl_.alarm_ = reinterpret_cast<::thingspect::api::Alarm*>(p);
  }
  return _impl_.alarm_;
}
inline ::thingspect::api::Alarm* UpdateAlarmRequest::mutable_alarm() {
  ::thingspect::api::Alarm* _msg = _internal_mutable_alarm();
  // @@protoc_insertion_point(field_mutable:thingspect.api.UpdateAlarmRequest.alarm)
  return _msg;
}
inline void UpdateAlarmRequest::set_allocated_alarm(::thingspect::api::Alarm* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::thingspect::api::Alarm*>(_impl_.alarm_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::thingspect::api::Alarm*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.alarm_ = reinterpret_cast<::thingspect::api::Alarm*>(value);
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.UpdateAlarmRequest.alarm)
}

// .google.protobuf.FieldMask update_mask = 2;
inline bool UpdateAlarmRequest::has_update_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.update_mask_ != nullptr);
  return value;
}
inline const ::google::protobuf::FieldMask& UpdateAlarmRequest::_internal_update_mask() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::FieldMask&>(::google::protobuf::_FieldMask_default_instance_);
}
inline const ::google::protobuf::FieldMask& UpdateAlarmRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:thingspect.api.UpdateAlarmRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateAlarmRequest::unsafe_arena_set_allocated_update_mask(::google::protobuf::FieldMask* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thingspect.api.UpdateAlarmRequest.update_mask)
}
inline ::google::protobuf::FieldMask* UpdateAlarmRequest::release_update_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FieldMask* released = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::FieldMask* UpdateAlarmRequest::unsafe_arena_release_update_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.UpdateAlarmRequest.update_mask)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::google::protobuf::FieldMask* UpdateAlarmRequest::_internal_mutable_update_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FieldMask>(GetArenaForAllocation());
    _impl_.update_mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(p);
  }
  return _impl_.update_mask_;
}
inline ::google::protobuf::FieldMask* UpdateAlarmRequest::mutable_update_mask() {
  ::google::protobuf::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:thingspect.api.UpdateAlarmRequest.update_mask)
  return _msg;
}
inline void UpdateAlarmRequest::set_allocated_update_mask(::google::protobuf::FieldMask* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_mask_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.update_mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(value);
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.UpdateAlarmRequest.update_mask)
}

// -------------------------------------------------------------------

// DeleteAlarmRequest

// string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void DeleteAlarmRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& DeleteAlarmRequest::id() const {
  // @@protoc_insertion_point(field_get:thingspect.api.DeleteAlarmRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteAlarmRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.DeleteAlarmRequest.id)
}
inline std::string* DeleteAlarmRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:thingspect.api.DeleteAlarmRequest.id)
  return _s;
}
inline const std::string& DeleteAlarmRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void DeleteAlarmRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteAlarmRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* DeleteAlarmRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.DeleteAlarmRequest.id)
  return _impl_.id_.Release();
}
inline void DeleteAlarmRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.DeleteAlarmRequest.id)
}

// string rule_id = 2 [json_name = "ruleID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void DeleteAlarmRequest::clear_rule_id() {
  _impl_.rule_id_.ClearToEmpty();
}
inline const std::string& DeleteAlarmRequest::rule_id() const {
  // @@protoc_insertion_point(field_get:thingspect.api.DeleteAlarmRequest.rule_id)
  return _internal_rule_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteAlarmRequest::set_rule_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rule_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.DeleteAlarmRequest.rule_id)
}
inline std::string* DeleteAlarmRequest::mutable_rule_id() {
  std::string* _s = _internal_mutable_rule_id();
  // @@protoc_insertion_point(field_mutable:thingspect.api.DeleteAlarmRequest.rule_id)
  return _s;
}
inline const std::string& DeleteAlarmRequest::_internal_rule_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rule_id_.Get();
}
inline void DeleteAlarmRequest::_internal_set_rule_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rule_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteAlarmRequest::_internal_mutable_rule_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.rule_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DeleteAlarmRequest::release_rule_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.DeleteAlarmRequest.rule_id)
  return _impl_.rule_id_.Release();
}
inline void DeleteAlarmRequest::set_allocated_rule_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rule_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rule_id_.IsDefault()) {
          _impl_.rule_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.DeleteAlarmRequest.rule_id)
}

// -------------------------------------------------------------------

// ListAlarmsRequest

// int32 page_size = 1 [(.validate.rules) = {
inline void ListAlarmsRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline ::int32_t ListAlarmsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:thingspect.api.ListAlarmsRequest.page_size)
  return _internal_page_size();
}
inline void ListAlarmsRequest::set_page_size(::int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:thingspect.api.ListAlarmsRequest.page_size)
}
inline ::int32_t ListAlarmsRequest::_internal_page_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.page_size_;
}
inline void ListAlarmsRequest::_internal_set_page_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.page_size_ = value;
}

// string page_token = 2;
inline void ListAlarmsRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListAlarmsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:thingspect.api.ListAlarmsRequest.page_token)
  return _internal_page_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListAlarmsRequest::set_page_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.ListAlarmsRequest.page_token)
}
inline std::string* ListAlarmsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:thingspect.api.ListAlarmsRequest.page_token)
  return _s;
}
inline const std::string& ListAlarmsRequest::_internal_page_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.page_token_.Get();
}
inline void ListAlarmsRequest::_internal_set_page_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListAlarmsRequest::_internal_mutable_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.page_token_.Mutable( GetArenaForAllocation());
}
inline std::string* ListAlarmsRequest::release_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.ListAlarmsRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListAlarmsRequest::set_allocated_page_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.page_token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.page_token_.IsDefault()) {
          _impl_.page_token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.ListAlarmsRequest.page_token)
}

// string rule_id = 3 [json_name = "ruleID", (.validate.rules) = {
inline void ListAlarmsRequest::clear_rule_id() {
  _impl_.rule_id_.ClearToEmpty();
}
inline const std::string& ListAlarmsRequest::rule_id() const {
  // @@protoc_insertion_point(field_get:thingspect.api.ListAlarmsRequest.rule_id)
  return _internal_rule_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListAlarmsRequest::set_rule_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rule_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.ListAlarmsRequest.rule_id)
}
inline std::string* ListAlarmsRequest::mutable_rule_id() {
  std::string* _s = _internal_mutable_rule_id();
  // @@protoc_insertion_point(field_mutable:thingspect.api.ListAlarmsRequest.rule_id)
  return _s;
}
inline const std::string& ListAlarmsRequest::_internal_rule_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rule_id_.Get();
}
inline void ListAlarmsRequest::_internal_set_rule_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rule_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListAlarmsRequest::_internal_mutable_rule_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.rule_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ListAlarmsRequest::release_rule_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.ListAlarmsRequest.rule_id)
  return _impl_.rule_id_.Release();
}
inline void ListAlarmsRequest::set_allocated_rule_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rule_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rule_id_.IsDefault()) {
          _impl_.rule_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.ListAlarmsRequest.rule_id)
}

// -------------------------------------------------------------------

// ListAlarmsResponse

// repeated .thingspect.api.Alarm alarms = 1;
inline int ListAlarmsResponse::_internal_alarms_size() const {
  return _internal_alarms().size();
}
inline int ListAlarmsResponse::alarms_size() const {
  return _internal_alarms_size();
}
inline void ListAlarmsResponse::clear_alarms() {
  _internal_mutable_alarms()->Clear();
}
inline ::thingspect::api::Alarm* ListAlarmsResponse::mutable_alarms(int index) {
  // @@protoc_insertion_point(field_mutable:thingspect.api.ListAlarmsResponse.alarms)
  return _internal_mutable_alarms()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::thingspect::api::Alarm >*
ListAlarmsResponse::mutable_alarms() {
  // @@protoc_insertion_point(field_mutable_list:thingspect.api.ListAlarmsResponse.alarms)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_alarms();
}
inline const ::thingspect::api::Alarm& ListAlarmsResponse::alarms(int index) const {
  // @@protoc_insertion_point(field_get:thingspect.api.ListAlarmsResponse.alarms)
    return _internal_alarms().Get(index);
}
inline ::thingspect::api::Alarm* ListAlarmsResponse::add_alarms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::thingspect::api::Alarm* _add = _internal_mutable_alarms()->Add();
  // @@protoc_insertion_point(field_add:thingspect.api.ListAlarmsResponse.alarms)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::thingspect::api::Alarm >&
ListAlarmsResponse::alarms() const {
  // @@protoc_insertion_point(field_list:thingspect.api.ListAlarmsResponse.alarms)
  return _internal_alarms();
}
inline const ::google::protobuf::RepeatedPtrField<::thingspect::api::Alarm>&
ListAlarmsResponse::_internal_alarms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.alarms_;
}
inline ::google::protobuf::RepeatedPtrField<::thingspect::api::Alarm>*
ListAlarmsResponse::_internal_mutable_alarms() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.alarms_;
}

// string next_page_token = 2;
inline void ListAlarmsResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListAlarmsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:thingspect.api.ListAlarmsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListAlarmsResponse::set_next_page_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.next_page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.ListAlarmsResponse.next_page_token)
}
inline std::string* ListAlarmsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:thingspect.api.ListAlarmsResponse.next_page_token)
  return _s;
}
inline const std::string& ListAlarmsResponse::_internal_next_page_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.next_page_token_.Get();
}
inline void ListAlarmsResponse::_internal_set_next_page_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListAlarmsResponse::_internal_mutable_next_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.next_page_token_.Mutable( GetArenaForAllocation());
}
inline std::string* ListAlarmsResponse::release_next_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.ListAlarmsResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListAlarmsResponse::set_allocated_next_page_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.next_page_token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.next_page_token_.IsDefault()) {
          _impl_.next_page_token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.ListAlarmsResponse.next_page_token)
}

// int32 total_size = 3;
inline void ListAlarmsResponse::clear_total_size() {
  _impl_.total_size_ = 0;
}
inline ::int32_t ListAlarmsResponse::total_size() const {
  // @@protoc_insertion_point(field_get:thingspect.api.ListAlarmsResponse.total_size)
  return _internal_total_size();
}
inline void ListAlarmsResponse::set_total_size(::int32_t value) {
  _internal_set_total_size(value);
  // @@protoc_insertion_point(field_set:thingspect.api.ListAlarmsResponse.total_size)
}
inline ::int32_t ListAlarmsResponse::_internal_total_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_size_;
}
inline void ListAlarmsResponse::_internal_set_total_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_size_ = value;
}

// -------------------------------------------------------------------

// TestAlarmRequest

// .thingspect.common.DataPoint point = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool TestAlarmRequest::has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point_ != nullptr);
  return value;
}
inline const ::thingspect::common::DataPoint& TestAlarmRequest::_internal_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::thingspect::common::DataPoint* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::thingspect::common::DataPoint&>(::thingspect::common::_DataPoint_default_instance_);
}
inline const ::thingspect::common::DataPoint& TestAlarmRequest::point() const {
  // @@protoc_insertion_point(field_get:thingspect.api.TestAlarmRequest.point)
  return _internal_point();
}
inline void TestAlarmRequest::unsafe_arena_set_allocated_point(::thingspect::common::DataPoint* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = reinterpret_cast<::thingspect::common::DataPoint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thingspect.api.TestAlarmRequest.point)
}
inline ::thingspect::common::DataPoint* TestAlarmRequest::release_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thingspect::common::DataPoint* released = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::thingspect::common::DataPoint* TestAlarmRequest::unsafe_arena_release_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.TestAlarmRequest.point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thingspect::common::DataPoint* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::thingspect::common::DataPoint* TestAlarmRequest::_internal_mutable_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::thingspect::common::DataPoint>(GetArenaForAllocation());
    _impl_.point_ = reinterpret_cast<::thingspect::common::DataPoint*>(p);
  }
  return _impl_.point_;
}
inline ::thingspect::common::DataPoint* TestAlarmRequest::mutable_point() {
  ::thingspect::common::DataPoint* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:thingspect.api.TestAlarmRequest.point)
  return _msg;
}
inline void TestAlarmRequest::set_allocated_point(::thingspect::common::DataPoint* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.point_ = reinterpret_cast<::thingspect::common::DataPoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.TestAlarmRequest.point)
}

// .thingspect.api.Rule rule = 2 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool TestAlarmRequest::has_rule() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rule_ != nullptr);
  return value;
}
inline void TestAlarmRequest::clear_rule() {
  if (_impl_.rule_ != nullptr) _impl_.rule_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::thingspect::api::Rule& TestAlarmRequest::_internal_rule() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::thingspect::api::Rule* p = _impl_.rule_;
  return p != nullptr ? *p : reinterpret_cast<const ::thingspect::api::Rule&>(::thingspect::api::_Rule_default_instance_);
}
inline const ::thingspect::api::Rule& TestAlarmRequest::rule() const {
  // @@protoc_insertion_point(field_get:thingspect.api.TestAlarmRequest.rule)
  return _internal_rule();
}
inline void TestAlarmRequest::unsafe_arena_set_allocated_rule(::thingspect::api::Rule* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rule_);
  }
  _impl_.rule_ = reinterpret_cast<::thingspect::api::Rule*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thingspect.api.TestAlarmRequest.rule)
}
inline ::thingspect::api::Rule* TestAlarmRequest::release_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::thingspect::api::Rule* released = _impl_.rule_;
  _impl_.rule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::thingspect::api::Rule* TestAlarmRequest::unsafe_arena_release_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.TestAlarmRequest.rule)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::thingspect::api::Rule* temp = _impl_.rule_;
  _impl_.rule_ = nullptr;
  return temp;
}
inline ::thingspect::api::Rule* TestAlarmRequest::_internal_mutable_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.rule_ == nullptr) {
    auto* p = CreateMaybeMessage<::thingspect::api::Rule>(GetArenaForAllocation());
    _impl_.rule_ = reinterpret_cast<::thingspect::api::Rule*>(p);
  }
  return _impl_.rule_;
}
inline ::thingspect::api::Rule* TestAlarmRequest::mutable_rule() {
  ::thingspect::api::Rule* _msg = _internal_mutable_rule();
  // @@protoc_insertion_point(field_mutable:thingspect.api.TestAlarmRequest.rule)
  return _msg;
}
inline void TestAlarmRequest::set_allocated_rule(::thingspect::api::Rule* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::thingspect::api::Rule*>(_impl_.rule_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::thingspect::api::Rule*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rule_ = reinterpret_cast<::thingspect::api::Rule*>(value);
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.TestAlarmRequest.rule)
}

// .thingspect.api.Device device = 3 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool TestAlarmRequest::has_device() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_ != nullptr);
  return value;
}
inline const ::thingspect::api::Device& TestAlarmRequest::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::thingspect::api::Device* p = _impl_.device_;
  return p != nullptr ? *p : reinterpret_cast<const ::thingspect::api::Device&>(::thingspect::api::_Device_default_instance_);
}
inline const ::thingspect::api::Device& TestAlarmRequest::device() const {
  // @@protoc_insertion_point(field_get:thingspect.api.TestAlarmRequest.device)
  return _internal_device();
}
inline void TestAlarmRequest::unsafe_arena_set_allocated_device(::thingspect::api::Device* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.device_);
  }
  _impl_.device_ = reinterpret_cast<::thingspect::api::Device*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thingspect.api.TestAlarmRequest.device)
}
inline ::thingspect::api::Device* TestAlarmRequest::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::thingspect::api::Device* released = _impl_.device_;
  _impl_.device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::thingspect::api::Device* TestAlarmRequest::unsafe_arena_release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.TestAlarmRequest.device)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::thingspect::api::Device* temp = _impl_.device_;
  _impl_.device_ = nullptr;
  return temp;
}
inline ::thingspect::api::Device* TestAlarmRequest::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.device_ == nullptr) {
    auto* p = CreateMaybeMessage<::thingspect::api::Device>(GetArenaForAllocation());
    _impl_.device_ = reinterpret_cast<::thingspect::api::Device*>(p);
  }
  return _impl_.device_;
}
inline ::thingspect::api::Device* TestAlarmRequest::mutable_device() {
  ::thingspect::api::Device* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:thingspect.api.TestAlarmRequest.device)
  return _msg;
}
inline void TestAlarmRequest::set_allocated_device(::thingspect::api::Device* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.device_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.device_ = reinterpret_cast<::thingspect::api::Device*>(value);
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.TestAlarmRequest.device)
}

// .thingspect.api.Alarm alarm = 4 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool TestAlarmRequest::has_alarm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.alarm_ != nullptr);
  return value;
}
inline void TestAlarmRequest::clear_alarm() {
  if (_impl_.alarm_ != nullptr) _impl_.alarm_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::thingspect::api::Alarm& TestAlarmRequest::_internal_alarm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::thingspect::api::Alarm* p = _impl_.alarm_;
  return p != nullptr ? *p : reinterpret_cast<const ::thingspect::api::Alarm&>(::thingspect::api::_Alarm_default_instance_);
}
inline const ::thingspect::api::Alarm& TestAlarmRequest::alarm() const {
  // @@protoc_insertion_point(field_get:thingspect.api.TestAlarmRequest.alarm)
  return _internal_alarm();
}
inline void TestAlarmRequest::unsafe_arena_set_allocated_alarm(::thingspect::api::Alarm* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.alarm_);
  }
  _impl_.alarm_ = reinterpret_cast<::thingspect::api::Alarm*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thingspect.api.TestAlarmRequest.alarm)
}
inline ::thingspect::api::Alarm* TestAlarmRequest::release_alarm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::thingspect::api::Alarm* released = _impl_.alarm_;
  _impl_.alarm_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::thingspect::api::Alarm* TestAlarmRequest::unsafe_arena_release_alarm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.TestAlarmRequest.alarm)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::thingspect::api::Alarm* temp = _impl_.alarm_;
  _impl_.alarm_ = nullptr;
  return temp;
}
inline ::thingspect::api::Alarm* TestAlarmRequest::_internal_mutable_alarm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.alarm_ == nullptr) {
    auto* p = CreateMaybeMessage<::thingspect::api::Alarm>(GetArenaForAllocation());
    _impl_.alarm_ = reinterpret_cast<::thingspect::api::Alarm*>(p);
  }
  return _impl_.alarm_;
}
inline ::thingspect::api::Alarm* TestAlarmRequest::mutable_alarm() {
  ::thingspect::api::Alarm* _msg = _internal_mutable_alarm();
  // @@protoc_insertion_point(field_mutable:thingspect.api.TestAlarmRequest.alarm)
  return _msg;
}
inline void TestAlarmRequest::set_allocated_alarm(::thingspect::api::Alarm* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::thingspect::api::Alarm*>(_impl_.alarm_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::thingspect::api::Alarm*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.alarm_ = reinterpret_cast<::thingspect::api::Alarm*>(value);
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.TestAlarmRequest.alarm)
}

// -------------------------------------------------------------------

// TestAlarmResponse

// string result = 1;
inline void TestAlarmResponse::clear_result() {
  _impl_.result_.ClearToEmpty();
}
inline const std::string& TestAlarmResponse::result() const {
  // @@protoc_insertion_point(field_get:thingspect.api.TestAlarmResponse.result)
  return _internal_result();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TestAlarmResponse::set_result(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.result_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:thingspect.api.TestAlarmResponse.result)
}
inline std::string* TestAlarmResponse::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:thingspect.api.TestAlarmResponse.result)
  return _s;
}
inline const std::string& TestAlarmResponse::_internal_result() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.result_.Get();
}
inline void TestAlarmResponse::_internal_set_result(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.result_.Set(value, GetArenaForAllocation());
}
inline std::string* TestAlarmResponse::_internal_mutable_result() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.result_.Mutable( GetArenaForAllocation());
}
inline std::string* TestAlarmResponse::release_result() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:thingspect.api.TestAlarmResponse.result)
  return _impl_.result_.Release();
}
inline void TestAlarmResponse::set_allocated_result(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.result_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.result_.IsDefault()) {
          _impl_.result_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thingspect.api.TestAlarmResponse.result)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace api
}  // namespace thingspect


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::thingspect::api::AlarmType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::thingspect::api::AlarmType>() {
  return ::thingspect::api::AlarmType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2fthingspect_5frule_5falarm_2eproto_2epb_2eh
