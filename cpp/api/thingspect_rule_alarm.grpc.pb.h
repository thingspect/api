// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: api/thingspect_rule_alarm.proto
#ifndef GRPC_api_2fthingspect_5frule_5falarm_2eproto__INCLUDED
#define GRPC_api_2fthingspect_5frule_5falarm_2eproto__INCLUDED

#include "api/thingspect_rule_alarm.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace thingspect {
namespace api {

// RuleAlarmService contains functions to query and modify rules and alarms.
class RuleAlarmService final {
 public:
  static constexpr char const* service_full_name() {
    return "thingspect.api.RuleAlarmService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Create a rule. Rules generate events when conditions are met.
    virtual ::grpc::Status CreateRule(::grpc::ClientContext* context, const ::thingspect::api::CreateRuleRequest& request, ::thingspect::api::Rule* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Rule>> AsyncCreateRule(::grpc::ClientContext* context, const ::thingspect::api::CreateRuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Rule>>(AsyncCreateRuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Rule>> PrepareAsyncCreateRule(::grpc::ClientContext* context, const ::thingspect::api::CreateRuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Rule>>(PrepareAsyncCreateRuleRaw(context, request, cq));
    }
    // Create an alarm. Alarms generate alerts via parent rules.
    virtual ::grpc::Status CreateAlarm(::grpc::ClientContext* context, const ::thingspect::api::CreateAlarmRequest& request, ::thingspect::api::Alarm* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Alarm>> AsyncCreateAlarm(::grpc::ClientContext* context, const ::thingspect::api::CreateAlarmRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Alarm>>(AsyncCreateAlarmRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Alarm>> PrepareAsyncCreateAlarm(::grpc::ClientContext* context, const ::thingspect::api::CreateAlarmRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Alarm>>(PrepareAsyncCreateAlarmRaw(context, request, cq));
    }
    // Get a rule by ID. Rules generate events when conditions are met.
    virtual ::grpc::Status GetRule(::grpc::ClientContext* context, const ::thingspect::api::GetRuleRequest& request, ::thingspect::api::Rule* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Rule>> AsyncGetRule(::grpc::ClientContext* context, const ::thingspect::api::GetRuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Rule>>(AsyncGetRuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Rule>> PrepareAsyncGetRule(::grpc::ClientContext* context, const ::thingspect::api::GetRuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Rule>>(PrepareAsyncGetRuleRaw(context, request, cq));
    }
    // Get an alarm by ID. Alarms generate alerts via parent rules.
    virtual ::grpc::Status GetAlarm(::grpc::ClientContext* context, const ::thingspect::api::GetAlarmRequest& request, ::thingspect::api::Alarm* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Alarm>> AsyncGetAlarm(::grpc::ClientContext* context, const ::thingspect::api::GetAlarmRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Alarm>>(AsyncGetAlarmRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Alarm>> PrepareAsyncGetAlarm(::grpc::ClientContext* context, const ::thingspect::api::GetAlarmRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Alarm>>(PrepareAsyncGetAlarmRaw(context, request, cq));
    }
    // Update a rule. Rules generate events when conditions are met.
    virtual ::grpc::Status UpdateRule(::grpc::ClientContext* context, const ::thingspect::api::UpdateRuleRequest& request, ::thingspect::api::Rule* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Rule>> AsyncUpdateRule(::grpc::ClientContext* context, const ::thingspect::api::UpdateRuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Rule>>(AsyncUpdateRuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Rule>> PrepareAsyncUpdateRule(::grpc::ClientContext* context, const ::thingspect::api::UpdateRuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Rule>>(PrepareAsyncUpdateRuleRaw(context, request, cq));
    }
    // Update an alarm. Alarms generate alerts via parent rules.
    virtual ::grpc::Status UpdateAlarm(::grpc::ClientContext* context, const ::thingspect::api::UpdateAlarmRequest& request, ::thingspect::api::Alarm* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Alarm>> AsyncUpdateAlarm(::grpc::ClientContext* context, const ::thingspect::api::UpdateAlarmRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Alarm>>(AsyncUpdateAlarmRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Alarm>> PrepareAsyncUpdateAlarm(::grpc::ClientContext* context, const ::thingspect::api::UpdateAlarmRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Alarm>>(PrepareAsyncUpdateAlarmRaw(context, request, cq));
    }
    // Delete a rule by ID. Rules generate events when conditions are met.
    virtual ::grpc::Status DeleteRule(::grpc::ClientContext* context, const ::thingspect::api::DeleteRuleRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncDeleteRule(::grpc::ClientContext* context, const ::thingspect::api::DeleteRuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncDeleteRuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncDeleteRule(::grpc::ClientContext* context, const ::thingspect::api::DeleteRuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncDeleteRuleRaw(context, request, cq));
    }
    // Delete an alarm by ID. Alarms generate alerts via parent rules.
    virtual ::grpc::Status DeleteAlarm(::grpc::ClientContext* context, const ::thingspect::api::DeleteAlarmRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncDeleteAlarm(::grpc::ClientContext* context, const ::thingspect::api::DeleteAlarmRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncDeleteAlarmRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncDeleteAlarm(::grpc::ClientContext* context, const ::thingspect::api::DeleteAlarmRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncDeleteAlarmRaw(context, request, cq));
    }
    // List all rules. Rules generate events when conditions are met.
    virtual ::grpc::Status ListRules(::grpc::ClientContext* context, const ::thingspect::api::ListRulesRequest& request, ::thingspect::api::ListRulesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::ListRulesResponse>> AsyncListRules(::grpc::ClientContext* context, const ::thingspect::api::ListRulesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::ListRulesResponse>>(AsyncListRulesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::ListRulesResponse>> PrepareAsyncListRules(::grpc::ClientContext* context, const ::thingspect::api::ListRulesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::ListRulesResponse>>(PrepareAsyncListRulesRaw(context, request, cq));
    }
    // List alarms. Alarms generate alerts via parent rules.
    virtual ::grpc::Status ListAlarms(::grpc::ClientContext* context, const ::thingspect::api::ListAlarmsRequest& request, ::thingspect::api::ListAlarmsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::ListAlarmsResponse>> AsyncListAlarms(::grpc::ClientContext* context, const ::thingspect::api::ListAlarmsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::ListAlarmsResponse>>(AsyncListAlarmsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::ListAlarmsResponse>> PrepareAsyncListAlarms(::grpc::ClientContext* context, const ::thingspect::api::ListAlarmsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::ListAlarmsResponse>>(PrepareAsyncListAlarmsRaw(context, request, cq));
    }
    // Test a rule. Rules generate events when conditions are met.
    virtual ::grpc::Status TestRule(::grpc::ClientContext* context, const ::thingspect::api::TestRuleRequest& request, ::thingspect::api::TestRuleResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::TestRuleResponse>> AsyncTestRule(::grpc::ClientContext* context, const ::thingspect::api::TestRuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::TestRuleResponse>>(AsyncTestRuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::TestRuleResponse>> PrepareAsyncTestRule(::grpc::ClientContext* context, const ::thingspect::api::TestRuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::TestRuleResponse>>(PrepareAsyncTestRuleRaw(context, request, cq));
    }
    // Test an alarm. Alarms generate alerts via parent rules.
    virtual ::grpc::Status TestAlarm(::grpc::ClientContext* context, const ::thingspect::api::TestAlarmRequest& request, ::thingspect::api::TestAlarmResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::TestAlarmResponse>> AsyncTestAlarm(::grpc::ClientContext* context, const ::thingspect::api::TestAlarmRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::TestAlarmResponse>>(AsyncTestAlarmRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::TestAlarmResponse>> PrepareAsyncTestAlarm(::grpc::ClientContext* context, const ::thingspect::api::TestAlarmRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::TestAlarmResponse>>(PrepareAsyncTestAlarmRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Create a rule. Rules generate events when conditions are met.
      virtual void CreateRule(::grpc::ClientContext* context, const ::thingspect::api::CreateRuleRequest* request, ::thingspect::api::Rule* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateRule(::grpc::ClientContext* context, const ::thingspect::api::CreateRuleRequest* request, ::thingspect::api::Rule* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Create an alarm. Alarms generate alerts via parent rules.
      virtual void CreateAlarm(::grpc::ClientContext* context, const ::thingspect::api::CreateAlarmRequest* request, ::thingspect::api::Alarm* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateAlarm(::grpc::ClientContext* context, const ::thingspect::api::CreateAlarmRequest* request, ::thingspect::api::Alarm* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get a rule by ID. Rules generate events when conditions are met.
      virtual void GetRule(::grpc::ClientContext* context, const ::thingspect::api::GetRuleRequest* request, ::thingspect::api::Rule* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRule(::grpc::ClientContext* context, const ::thingspect::api::GetRuleRequest* request, ::thingspect::api::Rule* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get an alarm by ID. Alarms generate alerts via parent rules.
      virtual void GetAlarm(::grpc::ClientContext* context, const ::thingspect::api::GetAlarmRequest* request, ::thingspect::api::Alarm* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAlarm(::grpc::ClientContext* context, const ::thingspect::api::GetAlarmRequest* request, ::thingspect::api::Alarm* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Update a rule. Rules generate events when conditions are met.
      virtual void UpdateRule(::grpc::ClientContext* context, const ::thingspect::api::UpdateRuleRequest* request, ::thingspect::api::Rule* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateRule(::grpc::ClientContext* context, const ::thingspect::api::UpdateRuleRequest* request, ::thingspect::api::Rule* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Update an alarm. Alarms generate alerts via parent rules.
      virtual void UpdateAlarm(::grpc::ClientContext* context, const ::thingspect::api::UpdateAlarmRequest* request, ::thingspect::api::Alarm* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateAlarm(::grpc::ClientContext* context, const ::thingspect::api::UpdateAlarmRequest* request, ::thingspect::api::Alarm* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Delete a rule by ID. Rules generate events when conditions are met.
      virtual void DeleteRule(::grpc::ClientContext* context, const ::thingspect::api::DeleteRuleRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteRule(::grpc::ClientContext* context, const ::thingspect::api::DeleteRuleRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Delete an alarm by ID. Alarms generate alerts via parent rules.
      virtual void DeleteAlarm(::grpc::ClientContext* context, const ::thingspect::api::DeleteAlarmRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteAlarm(::grpc::ClientContext* context, const ::thingspect::api::DeleteAlarmRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // List all rules. Rules generate events when conditions are met.
      virtual void ListRules(::grpc::ClientContext* context, const ::thingspect::api::ListRulesRequest* request, ::thingspect::api::ListRulesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListRules(::grpc::ClientContext* context, const ::thingspect::api::ListRulesRequest* request, ::thingspect::api::ListRulesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // List alarms. Alarms generate alerts via parent rules.
      virtual void ListAlarms(::grpc::ClientContext* context, const ::thingspect::api::ListAlarmsRequest* request, ::thingspect::api::ListAlarmsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListAlarms(::grpc::ClientContext* context, const ::thingspect::api::ListAlarmsRequest* request, ::thingspect::api::ListAlarmsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Test a rule. Rules generate events when conditions are met.
      virtual void TestRule(::grpc::ClientContext* context, const ::thingspect::api::TestRuleRequest* request, ::thingspect::api::TestRuleResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TestRule(::grpc::ClientContext* context, const ::thingspect::api::TestRuleRequest* request, ::thingspect::api::TestRuleResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Test an alarm. Alarms generate alerts via parent rules.
      virtual void TestAlarm(::grpc::ClientContext* context, const ::thingspect::api::TestAlarmRequest* request, ::thingspect::api::TestAlarmResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TestAlarm(::grpc::ClientContext* context, const ::thingspect::api::TestAlarmRequest* request, ::thingspect::api::TestAlarmResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Rule>* AsyncCreateRuleRaw(::grpc::ClientContext* context, const ::thingspect::api::CreateRuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Rule>* PrepareAsyncCreateRuleRaw(::grpc::ClientContext* context, const ::thingspect::api::CreateRuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Alarm>* AsyncCreateAlarmRaw(::grpc::ClientContext* context, const ::thingspect::api::CreateAlarmRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Alarm>* PrepareAsyncCreateAlarmRaw(::grpc::ClientContext* context, const ::thingspect::api::CreateAlarmRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Rule>* AsyncGetRuleRaw(::grpc::ClientContext* context, const ::thingspect::api::GetRuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Rule>* PrepareAsyncGetRuleRaw(::grpc::ClientContext* context, const ::thingspect::api::GetRuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Alarm>* AsyncGetAlarmRaw(::grpc::ClientContext* context, const ::thingspect::api::GetAlarmRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Alarm>* PrepareAsyncGetAlarmRaw(::grpc::ClientContext* context, const ::thingspect::api::GetAlarmRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Rule>* AsyncUpdateRuleRaw(::grpc::ClientContext* context, const ::thingspect::api::UpdateRuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Rule>* PrepareAsyncUpdateRuleRaw(::grpc::ClientContext* context, const ::thingspect::api::UpdateRuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Alarm>* AsyncUpdateAlarmRaw(::grpc::ClientContext* context, const ::thingspect::api::UpdateAlarmRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::Alarm>* PrepareAsyncUpdateAlarmRaw(::grpc::ClientContext* context, const ::thingspect::api::UpdateAlarmRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncDeleteRuleRaw(::grpc::ClientContext* context, const ::thingspect::api::DeleteRuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncDeleteRuleRaw(::grpc::ClientContext* context, const ::thingspect::api::DeleteRuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncDeleteAlarmRaw(::grpc::ClientContext* context, const ::thingspect::api::DeleteAlarmRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncDeleteAlarmRaw(::grpc::ClientContext* context, const ::thingspect::api::DeleteAlarmRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::ListRulesResponse>* AsyncListRulesRaw(::grpc::ClientContext* context, const ::thingspect::api::ListRulesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::ListRulesResponse>* PrepareAsyncListRulesRaw(::grpc::ClientContext* context, const ::thingspect::api::ListRulesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::ListAlarmsResponse>* AsyncListAlarmsRaw(::grpc::ClientContext* context, const ::thingspect::api::ListAlarmsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::ListAlarmsResponse>* PrepareAsyncListAlarmsRaw(::grpc::ClientContext* context, const ::thingspect::api::ListAlarmsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::TestRuleResponse>* AsyncTestRuleRaw(::grpc::ClientContext* context, const ::thingspect::api::TestRuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::TestRuleResponse>* PrepareAsyncTestRuleRaw(::grpc::ClientContext* context, const ::thingspect::api::TestRuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::TestAlarmResponse>* AsyncTestAlarmRaw(::grpc::ClientContext* context, const ::thingspect::api::TestAlarmRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thingspect::api::TestAlarmResponse>* PrepareAsyncTestAlarmRaw(::grpc::ClientContext* context, const ::thingspect::api::TestAlarmRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status CreateRule(::grpc::ClientContext* context, const ::thingspect::api::CreateRuleRequest& request, ::thingspect::api::Rule* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Rule>> AsyncCreateRule(::grpc::ClientContext* context, const ::thingspect::api::CreateRuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Rule>>(AsyncCreateRuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Rule>> PrepareAsyncCreateRule(::grpc::ClientContext* context, const ::thingspect::api::CreateRuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Rule>>(PrepareAsyncCreateRuleRaw(context, request, cq));
    }
    ::grpc::Status CreateAlarm(::grpc::ClientContext* context, const ::thingspect::api::CreateAlarmRequest& request, ::thingspect::api::Alarm* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Alarm>> AsyncCreateAlarm(::grpc::ClientContext* context, const ::thingspect::api::CreateAlarmRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Alarm>>(AsyncCreateAlarmRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Alarm>> PrepareAsyncCreateAlarm(::grpc::ClientContext* context, const ::thingspect::api::CreateAlarmRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Alarm>>(PrepareAsyncCreateAlarmRaw(context, request, cq));
    }
    ::grpc::Status GetRule(::grpc::ClientContext* context, const ::thingspect::api::GetRuleRequest& request, ::thingspect::api::Rule* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Rule>> AsyncGetRule(::grpc::ClientContext* context, const ::thingspect::api::GetRuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Rule>>(AsyncGetRuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Rule>> PrepareAsyncGetRule(::grpc::ClientContext* context, const ::thingspect::api::GetRuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Rule>>(PrepareAsyncGetRuleRaw(context, request, cq));
    }
    ::grpc::Status GetAlarm(::grpc::ClientContext* context, const ::thingspect::api::GetAlarmRequest& request, ::thingspect::api::Alarm* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Alarm>> AsyncGetAlarm(::grpc::ClientContext* context, const ::thingspect::api::GetAlarmRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Alarm>>(AsyncGetAlarmRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Alarm>> PrepareAsyncGetAlarm(::grpc::ClientContext* context, const ::thingspect::api::GetAlarmRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Alarm>>(PrepareAsyncGetAlarmRaw(context, request, cq));
    }
    ::grpc::Status UpdateRule(::grpc::ClientContext* context, const ::thingspect::api::UpdateRuleRequest& request, ::thingspect::api::Rule* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Rule>> AsyncUpdateRule(::grpc::ClientContext* context, const ::thingspect::api::UpdateRuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Rule>>(AsyncUpdateRuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Rule>> PrepareAsyncUpdateRule(::grpc::ClientContext* context, const ::thingspect::api::UpdateRuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Rule>>(PrepareAsyncUpdateRuleRaw(context, request, cq));
    }
    ::grpc::Status UpdateAlarm(::grpc::ClientContext* context, const ::thingspect::api::UpdateAlarmRequest& request, ::thingspect::api::Alarm* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Alarm>> AsyncUpdateAlarm(::grpc::ClientContext* context, const ::thingspect::api::UpdateAlarmRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Alarm>>(AsyncUpdateAlarmRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Alarm>> PrepareAsyncUpdateAlarm(::grpc::ClientContext* context, const ::thingspect::api::UpdateAlarmRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::Alarm>>(PrepareAsyncUpdateAlarmRaw(context, request, cq));
    }
    ::grpc::Status DeleteRule(::grpc::ClientContext* context, const ::thingspect::api::DeleteRuleRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncDeleteRule(::grpc::ClientContext* context, const ::thingspect::api::DeleteRuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncDeleteRuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncDeleteRule(::grpc::ClientContext* context, const ::thingspect::api::DeleteRuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncDeleteRuleRaw(context, request, cq));
    }
    ::grpc::Status DeleteAlarm(::grpc::ClientContext* context, const ::thingspect::api::DeleteAlarmRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncDeleteAlarm(::grpc::ClientContext* context, const ::thingspect::api::DeleteAlarmRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncDeleteAlarmRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncDeleteAlarm(::grpc::ClientContext* context, const ::thingspect::api::DeleteAlarmRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncDeleteAlarmRaw(context, request, cq));
    }
    ::grpc::Status ListRules(::grpc::ClientContext* context, const ::thingspect::api::ListRulesRequest& request, ::thingspect::api::ListRulesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::ListRulesResponse>> AsyncListRules(::grpc::ClientContext* context, const ::thingspect::api::ListRulesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::ListRulesResponse>>(AsyncListRulesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::ListRulesResponse>> PrepareAsyncListRules(::grpc::ClientContext* context, const ::thingspect::api::ListRulesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::ListRulesResponse>>(PrepareAsyncListRulesRaw(context, request, cq));
    }
    ::grpc::Status ListAlarms(::grpc::ClientContext* context, const ::thingspect::api::ListAlarmsRequest& request, ::thingspect::api::ListAlarmsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::ListAlarmsResponse>> AsyncListAlarms(::grpc::ClientContext* context, const ::thingspect::api::ListAlarmsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::ListAlarmsResponse>>(AsyncListAlarmsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::ListAlarmsResponse>> PrepareAsyncListAlarms(::grpc::ClientContext* context, const ::thingspect::api::ListAlarmsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::ListAlarmsResponse>>(PrepareAsyncListAlarmsRaw(context, request, cq));
    }
    ::grpc::Status TestRule(::grpc::ClientContext* context, const ::thingspect::api::TestRuleRequest& request, ::thingspect::api::TestRuleResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::TestRuleResponse>> AsyncTestRule(::grpc::ClientContext* context, const ::thingspect::api::TestRuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::TestRuleResponse>>(AsyncTestRuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::TestRuleResponse>> PrepareAsyncTestRule(::grpc::ClientContext* context, const ::thingspect::api::TestRuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::TestRuleResponse>>(PrepareAsyncTestRuleRaw(context, request, cq));
    }
    ::grpc::Status TestAlarm(::grpc::ClientContext* context, const ::thingspect::api::TestAlarmRequest& request, ::thingspect::api::TestAlarmResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::TestAlarmResponse>> AsyncTestAlarm(::grpc::ClientContext* context, const ::thingspect::api::TestAlarmRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::TestAlarmResponse>>(AsyncTestAlarmRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::TestAlarmResponse>> PrepareAsyncTestAlarm(::grpc::ClientContext* context, const ::thingspect::api::TestAlarmRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thingspect::api::TestAlarmResponse>>(PrepareAsyncTestAlarmRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void CreateRule(::grpc::ClientContext* context, const ::thingspect::api::CreateRuleRequest* request, ::thingspect::api::Rule* response, std::function<void(::grpc::Status)>) override;
      void CreateRule(::grpc::ClientContext* context, const ::thingspect::api::CreateRuleRequest* request, ::thingspect::api::Rule* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CreateAlarm(::grpc::ClientContext* context, const ::thingspect::api::CreateAlarmRequest* request, ::thingspect::api::Alarm* response, std::function<void(::grpc::Status)>) override;
      void CreateAlarm(::grpc::ClientContext* context, const ::thingspect::api::CreateAlarmRequest* request, ::thingspect::api::Alarm* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetRule(::grpc::ClientContext* context, const ::thingspect::api::GetRuleRequest* request, ::thingspect::api::Rule* response, std::function<void(::grpc::Status)>) override;
      void GetRule(::grpc::ClientContext* context, const ::thingspect::api::GetRuleRequest* request, ::thingspect::api::Rule* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetAlarm(::grpc::ClientContext* context, const ::thingspect::api::GetAlarmRequest* request, ::thingspect::api::Alarm* response, std::function<void(::grpc::Status)>) override;
      void GetAlarm(::grpc::ClientContext* context, const ::thingspect::api::GetAlarmRequest* request, ::thingspect::api::Alarm* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UpdateRule(::grpc::ClientContext* context, const ::thingspect::api::UpdateRuleRequest* request, ::thingspect::api::Rule* response, std::function<void(::grpc::Status)>) override;
      void UpdateRule(::grpc::ClientContext* context, const ::thingspect::api::UpdateRuleRequest* request, ::thingspect::api::Rule* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UpdateAlarm(::grpc::ClientContext* context, const ::thingspect::api::UpdateAlarmRequest* request, ::thingspect::api::Alarm* response, std::function<void(::grpc::Status)>) override;
      void UpdateAlarm(::grpc::ClientContext* context, const ::thingspect::api::UpdateAlarmRequest* request, ::thingspect::api::Alarm* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DeleteRule(::grpc::ClientContext* context, const ::thingspect::api::DeleteRuleRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void DeleteRule(::grpc::ClientContext* context, const ::thingspect::api::DeleteRuleRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DeleteAlarm(::grpc::ClientContext* context, const ::thingspect::api::DeleteAlarmRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void DeleteAlarm(::grpc::ClientContext* context, const ::thingspect::api::DeleteAlarmRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListRules(::grpc::ClientContext* context, const ::thingspect::api::ListRulesRequest* request, ::thingspect::api::ListRulesResponse* response, std::function<void(::grpc::Status)>) override;
      void ListRules(::grpc::ClientContext* context, const ::thingspect::api::ListRulesRequest* request, ::thingspect::api::ListRulesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ListAlarms(::grpc::ClientContext* context, const ::thingspect::api::ListAlarmsRequest* request, ::thingspect::api::ListAlarmsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListAlarms(::grpc::ClientContext* context, const ::thingspect::api::ListAlarmsRequest* request, ::thingspect::api::ListAlarmsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void TestRule(::grpc::ClientContext* context, const ::thingspect::api::TestRuleRequest* request, ::thingspect::api::TestRuleResponse* response, std::function<void(::grpc::Status)>) override;
      void TestRule(::grpc::ClientContext* context, const ::thingspect::api::TestRuleRequest* request, ::thingspect::api::TestRuleResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void TestAlarm(::grpc::ClientContext* context, const ::thingspect::api::TestAlarmRequest* request, ::thingspect::api::TestAlarmResponse* response, std::function<void(::grpc::Status)>) override;
      void TestAlarm(::grpc::ClientContext* context, const ::thingspect::api::TestAlarmRequest* request, ::thingspect::api::TestAlarmResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::thingspect::api::Rule>* AsyncCreateRuleRaw(::grpc::ClientContext* context, const ::thingspect::api::CreateRuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thingspect::api::Rule>* PrepareAsyncCreateRuleRaw(::grpc::ClientContext* context, const ::thingspect::api::CreateRuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thingspect::api::Alarm>* AsyncCreateAlarmRaw(::grpc::ClientContext* context, const ::thingspect::api::CreateAlarmRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thingspect::api::Alarm>* PrepareAsyncCreateAlarmRaw(::grpc::ClientContext* context, const ::thingspect::api::CreateAlarmRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thingspect::api::Rule>* AsyncGetRuleRaw(::grpc::ClientContext* context, const ::thingspect::api::GetRuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thingspect::api::Rule>* PrepareAsyncGetRuleRaw(::grpc::ClientContext* context, const ::thingspect::api::GetRuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thingspect::api::Alarm>* AsyncGetAlarmRaw(::grpc::ClientContext* context, const ::thingspect::api::GetAlarmRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thingspect::api::Alarm>* PrepareAsyncGetAlarmRaw(::grpc::ClientContext* context, const ::thingspect::api::GetAlarmRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thingspect::api::Rule>* AsyncUpdateRuleRaw(::grpc::ClientContext* context, const ::thingspect::api::UpdateRuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thingspect::api::Rule>* PrepareAsyncUpdateRuleRaw(::grpc::ClientContext* context, const ::thingspect::api::UpdateRuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thingspect::api::Alarm>* AsyncUpdateAlarmRaw(::grpc::ClientContext* context, const ::thingspect::api::UpdateAlarmRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thingspect::api::Alarm>* PrepareAsyncUpdateAlarmRaw(::grpc::ClientContext* context, const ::thingspect::api::UpdateAlarmRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncDeleteRuleRaw(::grpc::ClientContext* context, const ::thingspect::api::DeleteRuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncDeleteRuleRaw(::grpc::ClientContext* context, const ::thingspect::api::DeleteRuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncDeleteAlarmRaw(::grpc::ClientContext* context, const ::thingspect::api::DeleteAlarmRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncDeleteAlarmRaw(::grpc::ClientContext* context, const ::thingspect::api::DeleteAlarmRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thingspect::api::ListRulesResponse>* AsyncListRulesRaw(::grpc::ClientContext* context, const ::thingspect::api::ListRulesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thingspect::api::ListRulesResponse>* PrepareAsyncListRulesRaw(::grpc::ClientContext* context, const ::thingspect::api::ListRulesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thingspect::api::ListAlarmsResponse>* AsyncListAlarmsRaw(::grpc::ClientContext* context, const ::thingspect::api::ListAlarmsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thingspect::api::ListAlarmsResponse>* PrepareAsyncListAlarmsRaw(::grpc::ClientContext* context, const ::thingspect::api::ListAlarmsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thingspect::api::TestRuleResponse>* AsyncTestRuleRaw(::grpc::ClientContext* context, const ::thingspect::api::TestRuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thingspect::api::TestRuleResponse>* PrepareAsyncTestRuleRaw(::grpc::ClientContext* context, const ::thingspect::api::TestRuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thingspect::api::TestAlarmResponse>* AsyncTestAlarmRaw(::grpc::ClientContext* context, const ::thingspect::api::TestAlarmRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thingspect::api::TestAlarmResponse>* PrepareAsyncTestAlarmRaw(::grpc::ClientContext* context, const ::thingspect::api::TestAlarmRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_CreateRule_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateAlarm_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRule_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAlarm_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateRule_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateAlarm_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteRule_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteAlarm_;
    const ::grpc::internal::RpcMethod rpcmethod_ListRules_;
    const ::grpc::internal::RpcMethod rpcmethod_ListAlarms_;
    const ::grpc::internal::RpcMethod rpcmethod_TestRule_;
    const ::grpc::internal::RpcMethod rpcmethod_TestAlarm_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Create a rule. Rules generate events when conditions are met.
    virtual ::grpc::Status CreateRule(::grpc::ServerContext* context, const ::thingspect::api::CreateRuleRequest* request, ::thingspect::api::Rule* response);
    // Create an alarm. Alarms generate alerts via parent rules.
    virtual ::grpc::Status CreateAlarm(::grpc::ServerContext* context, const ::thingspect::api::CreateAlarmRequest* request, ::thingspect::api::Alarm* response);
    // Get a rule by ID. Rules generate events when conditions are met.
    virtual ::grpc::Status GetRule(::grpc::ServerContext* context, const ::thingspect::api::GetRuleRequest* request, ::thingspect::api::Rule* response);
    // Get an alarm by ID. Alarms generate alerts via parent rules.
    virtual ::grpc::Status GetAlarm(::grpc::ServerContext* context, const ::thingspect::api::GetAlarmRequest* request, ::thingspect::api::Alarm* response);
    // Update a rule. Rules generate events when conditions are met.
    virtual ::grpc::Status UpdateRule(::grpc::ServerContext* context, const ::thingspect::api::UpdateRuleRequest* request, ::thingspect::api::Rule* response);
    // Update an alarm. Alarms generate alerts via parent rules.
    virtual ::grpc::Status UpdateAlarm(::grpc::ServerContext* context, const ::thingspect::api::UpdateAlarmRequest* request, ::thingspect::api::Alarm* response);
    // Delete a rule by ID. Rules generate events when conditions are met.
    virtual ::grpc::Status DeleteRule(::grpc::ServerContext* context, const ::thingspect::api::DeleteRuleRequest* request, ::google::protobuf::Empty* response);
    // Delete an alarm by ID. Alarms generate alerts via parent rules.
    virtual ::grpc::Status DeleteAlarm(::grpc::ServerContext* context, const ::thingspect::api::DeleteAlarmRequest* request, ::google::protobuf::Empty* response);
    // List all rules. Rules generate events when conditions are met.
    virtual ::grpc::Status ListRules(::grpc::ServerContext* context, const ::thingspect::api::ListRulesRequest* request, ::thingspect::api::ListRulesResponse* response);
    // List alarms. Alarms generate alerts via parent rules.
    virtual ::grpc::Status ListAlarms(::grpc::ServerContext* context, const ::thingspect::api::ListAlarmsRequest* request, ::thingspect::api::ListAlarmsResponse* response);
    // Test a rule. Rules generate events when conditions are met.
    virtual ::grpc::Status TestRule(::grpc::ServerContext* context, const ::thingspect::api::TestRuleRequest* request, ::thingspect::api::TestRuleResponse* response);
    // Test an alarm. Alarms generate alerts via parent rules.
    virtual ::grpc::Status TestAlarm(::grpc::ServerContext* context, const ::thingspect::api::TestAlarmRequest* request, ::thingspect::api::TestAlarmResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateRule() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_CreateRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::CreateRuleRequest* /*request*/, ::thingspect::api::Rule* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateRule(::grpc::ServerContext* context, ::thingspect::api::CreateRuleRequest* request, ::grpc::ServerAsyncResponseWriter< ::thingspect::api::Rule>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateAlarm() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_CreateAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::CreateAlarmRequest* /*request*/, ::thingspect::api::Alarm* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateAlarm(::grpc::ServerContext* context, ::thingspect::api::CreateAlarmRequest* request, ::grpc::ServerAsyncResponseWriter< ::thingspect::api::Alarm>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRule() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::GetRuleRequest* /*request*/, ::thingspect::api::Rule* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRule(::grpc::ServerContext* context, ::thingspect::api::GetRuleRequest* request, ::grpc::ServerAsyncResponseWriter< ::thingspect::api::Rule>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAlarm() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::GetAlarmRequest* /*request*/, ::thingspect::api::Alarm* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAlarm(::grpc::ServerContext* context, ::thingspect::api::GetAlarmRequest* request, ::grpc::ServerAsyncResponseWriter< ::thingspect::api::Alarm>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateRule() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_UpdateRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::UpdateRuleRequest* /*request*/, ::thingspect::api::Rule* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateRule(::grpc::ServerContext* context, ::thingspect::api::UpdateRuleRequest* request, ::grpc::ServerAsyncResponseWriter< ::thingspect::api::Rule>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateAlarm() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_UpdateAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::UpdateAlarmRequest* /*request*/, ::thingspect::api::Alarm* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateAlarm(::grpc::ServerContext* context, ::thingspect::api::UpdateAlarmRequest* request, ::grpc::ServerAsyncResponseWriter< ::thingspect::api::Alarm>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteRule() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_DeleteRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::DeleteRuleRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteRule(::grpc::ServerContext* context, ::thingspect::api::DeleteRuleRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteAlarm() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_DeleteAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::DeleteAlarmRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteAlarm(::grpc::ServerContext* context, ::thingspect::api::DeleteAlarmRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListRules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListRules() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_ListRules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListRules(::grpc::ServerContext* /*context*/, const ::thingspect::api::ListRulesRequest* /*request*/, ::thingspect::api::ListRulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListRules(::grpc::ServerContext* context, ::thingspect::api::ListRulesRequest* request, ::grpc::ServerAsyncResponseWriter< ::thingspect::api::ListRulesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListAlarms : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListAlarms() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_ListAlarms() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAlarms(::grpc::ServerContext* /*context*/, const ::thingspect::api::ListAlarmsRequest* /*request*/, ::thingspect::api::ListAlarmsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListAlarms(::grpc::ServerContext* context, ::thingspect::api::ListAlarmsRequest* request, ::grpc::ServerAsyncResponseWriter< ::thingspect::api::ListAlarmsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TestRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TestRule() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_TestRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TestRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::TestRuleRequest* /*request*/, ::thingspect::api::TestRuleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTestRule(::grpc::ServerContext* context, ::thingspect::api::TestRuleRequest* request, ::grpc::ServerAsyncResponseWriter< ::thingspect::api::TestRuleResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TestAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TestAlarm() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_TestAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TestAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::TestAlarmRequest* /*request*/, ::thingspect::api::TestAlarmResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTestAlarm(::grpc::ServerContext* context, ::thingspect::api::TestAlarmRequest* request, ::grpc::ServerAsyncResponseWriter< ::thingspect::api::TestAlarmResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_CreateRule<WithAsyncMethod_CreateAlarm<WithAsyncMethod_GetRule<WithAsyncMethod_GetAlarm<WithAsyncMethod_UpdateRule<WithAsyncMethod_UpdateAlarm<WithAsyncMethod_DeleteRule<WithAsyncMethod_DeleteAlarm<WithAsyncMethod_ListRules<WithAsyncMethod_ListAlarms<WithAsyncMethod_TestRule<WithAsyncMethod_TestAlarm<Service > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_CreateRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateRule() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::thingspect::api::CreateRuleRequest, ::thingspect::api::Rule>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thingspect::api::CreateRuleRequest* request, ::thingspect::api::Rule* response) { return this->CreateRule(context, request, response); }));}
    void SetMessageAllocatorFor_CreateRule(
        ::grpc::MessageAllocator< ::thingspect::api::CreateRuleRequest, ::thingspect::api::Rule>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::thingspect::api::CreateRuleRequest, ::thingspect::api::Rule>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::CreateRuleRequest* /*request*/, ::thingspect::api::Rule* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateRule(
      ::grpc::CallbackServerContext* /*context*/, const ::thingspect::api::CreateRuleRequest* /*request*/, ::thingspect::api::Rule* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CreateAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateAlarm() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::thingspect::api::CreateAlarmRequest, ::thingspect::api::Alarm>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thingspect::api::CreateAlarmRequest* request, ::thingspect::api::Alarm* response) { return this->CreateAlarm(context, request, response); }));}
    void SetMessageAllocatorFor_CreateAlarm(
        ::grpc::MessageAllocator< ::thingspect::api::CreateAlarmRequest, ::thingspect::api::Alarm>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::thingspect::api::CreateAlarmRequest, ::thingspect::api::Alarm>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::CreateAlarmRequest* /*request*/, ::thingspect::api::Alarm* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateAlarm(
      ::grpc::CallbackServerContext* /*context*/, const ::thingspect::api::CreateAlarmRequest* /*request*/, ::thingspect::api::Alarm* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetRule() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::thingspect::api::GetRuleRequest, ::thingspect::api::Rule>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thingspect::api::GetRuleRequest* request, ::thingspect::api::Rule* response) { return this->GetRule(context, request, response); }));}
    void SetMessageAllocatorFor_GetRule(
        ::grpc::MessageAllocator< ::thingspect::api::GetRuleRequest, ::thingspect::api::Rule>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::thingspect::api::GetRuleRequest, ::thingspect::api::Rule>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::GetRuleRequest* /*request*/, ::thingspect::api::Rule* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRule(
      ::grpc::CallbackServerContext* /*context*/, const ::thingspect::api::GetRuleRequest* /*request*/, ::thingspect::api::Rule* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetAlarm() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::thingspect::api::GetAlarmRequest, ::thingspect::api::Alarm>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thingspect::api::GetAlarmRequest* request, ::thingspect::api::Alarm* response) { return this->GetAlarm(context, request, response); }));}
    void SetMessageAllocatorFor_GetAlarm(
        ::grpc::MessageAllocator< ::thingspect::api::GetAlarmRequest, ::thingspect::api::Alarm>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::thingspect::api::GetAlarmRequest, ::thingspect::api::Alarm>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::GetAlarmRequest* /*request*/, ::thingspect::api::Alarm* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAlarm(
      ::grpc::CallbackServerContext* /*context*/, const ::thingspect::api::GetAlarmRequest* /*request*/, ::thingspect::api::Alarm* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UpdateRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UpdateRule() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::thingspect::api::UpdateRuleRequest, ::thingspect::api::Rule>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thingspect::api::UpdateRuleRequest* request, ::thingspect::api::Rule* response) { return this->UpdateRule(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateRule(
        ::grpc::MessageAllocator< ::thingspect::api::UpdateRuleRequest, ::thingspect::api::Rule>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::thingspect::api::UpdateRuleRequest, ::thingspect::api::Rule>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UpdateRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::UpdateRuleRequest* /*request*/, ::thingspect::api::Rule* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateRule(
      ::grpc::CallbackServerContext* /*context*/, const ::thingspect::api::UpdateRuleRequest* /*request*/, ::thingspect::api::Rule* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UpdateAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UpdateAlarm() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::thingspect::api::UpdateAlarmRequest, ::thingspect::api::Alarm>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thingspect::api::UpdateAlarmRequest* request, ::thingspect::api::Alarm* response) { return this->UpdateAlarm(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateAlarm(
        ::grpc::MessageAllocator< ::thingspect::api::UpdateAlarmRequest, ::thingspect::api::Alarm>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::thingspect::api::UpdateAlarmRequest, ::thingspect::api::Alarm>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UpdateAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::UpdateAlarmRequest* /*request*/, ::thingspect::api::Alarm* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateAlarm(
      ::grpc::CallbackServerContext* /*context*/, const ::thingspect::api::UpdateAlarmRequest* /*request*/, ::thingspect::api::Alarm* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DeleteRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DeleteRule() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::thingspect::api::DeleteRuleRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thingspect::api::DeleteRuleRequest* request, ::google::protobuf::Empty* response) { return this->DeleteRule(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteRule(
        ::grpc::MessageAllocator< ::thingspect::api::DeleteRuleRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::thingspect::api::DeleteRuleRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DeleteRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::DeleteRuleRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteRule(
      ::grpc::CallbackServerContext* /*context*/, const ::thingspect::api::DeleteRuleRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DeleteAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DeleteAlarm() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::thingspect::api::DeleteAlarmRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thingspect::api::DeleteAlarmRequest* request, ::google::protobuf::Empty* response) { return this->DeleteAlarm(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteAlarm(
        ::grpc::MessageAllocator< ::thingspect::api::DeleteAlarmRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::thingspect::api::DeleteAlarmRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DeleteAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::DeleteAlarmRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteAlarm(
      ::grpc::CallbackServerContext* /*context*/, const ::thingspect::api::DeleteAlarmRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListRules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListRules() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::thingspect::api::ListRulesRequest, ::thingspect::api::ListRulesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thingspect::api::ListRulesRequest* request, ::thingspect::api::ListRulesResponse* response) { return this->ListRules(context, request, response); }));}
    void SetMessageAllocatorFor_ListRules(
        ::grpc::MessageAllocator< ::thingspect::api::ListRulesRequest, ::thingspect::api::ListRulesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::thingspect::api::ListRulesRequest, ::thingspect::api::ListRulesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListRules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListRules(::grpc::ServerContext* /*context*/, const ::thingspect::api::ListRulesRequest* /*request*/, ::thingspect::api::ListRulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListRules(
      ::grpc::CallbackServerContext* /*context*/, const ::thingspect::api::ListRulesRequest* /*request*/, ::thingspect::api::ListRulesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ListAlarms : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ListAlarms() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::thingspect::api::ListAlarmsRequest, ::thingspect::api::ListAlarmsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thingspect::api::ListAlarmsRequest* request, ::thingspect::api::ListAlarmsResponse* response) { return this->ListAlarms(context, request, response); }));}
    void SetMessageAllocatorFor_ListAlarms(
        ::grpc::MessageAllocator< ::thingspect::api::ListAlarmsRequest, ::thingspect::api::ListAlarmsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::thingspect::api::ListAlarmsRequest, ::thingspect::api::ListAlarmsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ListAlarms() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAlarms(::grpc::ServerContext* /*context*/, const ::thingspect::api::ListAlarmsRequest* /*request*/, ::thingspect::api::ListAlarmsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListAlarms(
      ::grpc::CallbackServerContext* /*context*/, const ::thingspect::api::ListAlarmsRequest* /*request*/, ::thingspect::api::ListAlarmsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_TestRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_TestRule() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::thingspect::api::TestRuleRequest, ::thingspect::api::TestRuleResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thingspect::api::TestRuleRequest* request, ::thingspect::api::TestRuleResponse* response) { return this->TestRule(context, request, response); }));}
    void SetMessageAllocatorFor_TestRule(
        ::grpc::MessageAllocator< ::thingspect::api::TestRuleRequest, ::thingspect::api::TestRuleResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::thingspect::api::TestRuleRequest, ::thingspect::api::TestRuleResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_TestRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TestRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::TestRuleRequest* /*request*/, ::thingspect::api::TestRuleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TestRule(
      ::grpc::CallbackServerContext* /*context*/, const ::thingspect::api::TestRuleRequest* /*request*/, ::thingspect::api::TestRuleResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_TestAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_TestAlarm() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::thingspect::api::TestAlarmRequest, ::thingspect::api::TestAlarmResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thingspect::api::TestAlarmRequest* request, ::thingspect::api::TestAlarmResponse* response) { return this->TestAlarm(context, request, response); }));}
    void SetMessageAllocatorFor_TestAlarm(
        ::grpc::MessageAllocator< ::thingspect::api::TestAlarmRequest, ::thingspect::api::TestAlarmResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::thingspect::api::TestAlarmRequest, ::thingspect::api::TestAlarmResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_TestAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TestAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::TestAlarmRequest* /*request*/, ::thingspect::api::TestAlarmResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TestAlarm(
      ::grpc::CallbackServerContext* /*context*/, const ::thingspect::api::TestAlarmRequest* /*request*/, ::thingspect::api::TestAlarmResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_CreateRule<WithCallbackMethod_CreateAlarm<WithCallbackMethod_GetRule<WithCallbackMethod_GetAlarm<WithCallbackMethod_UpdateRule<WithCallbackMethod_UpdateAlarm<WithCallbackMethod_DeleteRule<WithCallbackMethod_DeleteAlarm<WithCallbackMethod_ListRules<WithCallbackMethod_ListAlarms<WithCallbackMethod_TestRule<WithCallbackMethod_TestAlarm<Service > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_CreateRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateRule() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_CreateRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::CreateRuleRequest* /*request*/, ::thingspect::api::Rule* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateAlarm() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_CreateAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::CreateAlarmRequest* /*request*/, ::thingspect::api::Alarm* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRule() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::GetRuleRequest* /*request*/, ::thingspect::api::Rule* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAlarm() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::GetAlarmRequest* /*request*/, ::thingspect::api::Alarm* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateRule() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_UpdateRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::UpdateRuleRequest* /*request*/, ::thingspect::api::Rule* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateAlarm() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_UpdateAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::UpdateAlarmRequest* /*request*/, ::thingspect::api::Alarm* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteRule() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_DeleteRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::DeleteRuleRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteAlarm() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_DeleteAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::DeleteAlarmRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListRules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListRules() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_ListRules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListRules(::grpc::ServerContext* /*context*/, const ::thingspect::api::ListRulesRequest* /*request*/, ::thingspect::api::ListRulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListAlarms : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListAlarms() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_ListAlarms() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAlarms(::grpc::ServerContext* /*context*/, const ::thingspect::api::ListAlarmsRequest* /*request*/, ::thingspect::api::ListAlarmsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TestRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TestRule() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_TestRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TestRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::TestRuleRequest* /*request*/, ::thingspect::api::TestRuleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TestAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TestAlarm() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_TestAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TestAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::TestAlarmRequest* /*request*/, ::thingspect::api::TestAlarmResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateRule() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_CreateRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::CreateRuleRequest* /*request*/, ::thingspect::api::Rule* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateRule(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateAlarm() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_CreateAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::CreateAlarmRequest* /*request*/, ::thingspect::api::Alarm* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateAlarm(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRule() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::GetRuleRequest* /*request*/, ::thingspect::api::Rule* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRule(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAlarm() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::GetAlarmRequest* /*request*/, ::thingspect::api::Alarm* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAlarm(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateRule() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_UpdateRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::UpdateRuleRequest* /*request*/, ::thingspect::api::Rule* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateRule(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateAlarm() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_UpdateAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::UpdateAlarmRequest* /*request*/, ::thingspect::api::Alarm* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateAlarm(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteRule() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_DeleteRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::DeleteRuleRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteRule(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteAlarm() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_DeleteAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::DeleteAlarmRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteAlarm(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListRules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListRules() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_ListRules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListRules(::grpc::ServerContext* /*context*/, const ::thingspect::api::ListRulesRequest* /*request*/, ::thingspect::api::ListRulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListRules(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListAlarms : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListAlarms() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_ListAlarms() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAlarms(::grpc::ServerContext* /*context*/, const ::thingspect::api::ListAlarmsRequest* /*request*/, ::thingspect::api::ListAlarmsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListAlarms(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TestRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TestRule() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_TestRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TestRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::TestRuleRequest* /*request*/, ::thingspect::api::TestRuleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTestRule(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TestAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TestAlarm() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_TestAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TestAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::TestAlarmRequest* /*request*/, ::thingspect::api::TestAlarmResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTestAlarm(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateRule() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateRule(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::CreateRuleRequest* /*request*/, ::thingspect::api::Rule* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateRule(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateAlarm() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateAlarm(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::CreateAlarmRequest* /*request*/, ::thingspect::api::Alarm* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateAlarm(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetRule() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRule(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::GetRuleRequest* /*request*/, ::thingspect::api::Rule* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRule(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetAlarm() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAlarm(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::GetAlarmRequest* /*request*/, ::thingspect::api::Alarm* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAlarm(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UpdateRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UpdateRule() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateRule(context, request, response); }));
    }
    ~WithRawCallbackMethod_UpdateRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::UpdateRuleRequest* /*request*/, ::thingspect::api::Rule* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateRule(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UpdateAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UpdateAlarm() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateAlarm(context, request, response); }));
    }
    ~WithRawCallbackMethod_UpdateAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::UpdateAlarmRequest* /*request*/, ::thingspect::api::Alarm* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateAlarm(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DeleteRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DeleteRule() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteRule(context, request, response); }));
    }
    ~WithRawCallbackMethod_DeleteRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::DeleteRuleRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteRule(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DeleteAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DeleteAlarm() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteAlarm(context, request, response); }));
    }
    ~WithRawCallbackMethod_DeleteAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::DeleteAlarmRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteAlarm(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListRules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListRules() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListRules(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListRules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListRules(::grpc::ServerContext* /*context*/, const ::thingspect::api::ListRulesRequest* /*request*/, ::thingspect::api::ListRulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListRules(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ListAlarms : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ListAlarms() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListAlarms(context, request, response); }));
    }
    ~WithRawCallbackMethod_ListAlarms() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListAlarms(::grpc::ServerContext* /*context*/, const ::thingspect::api::ListAlarmsRequest* /*request*/, ::thingspect::api::ListAlarmsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ListAlarms(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_TestRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_TestRule() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TestRule(context, request, response); }));
    }
    ~WithRawCallbackMethod_TestRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TestRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::TestRuleRequest* /*request*/, ::thingspect::api::TestRuleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TestRule(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_TestAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_TestAlarm() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TestAlarm(context, request, response); }));
    }
    ~WithRawCallbackMethod_TestAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TestAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::TestAlarmRequest* /*request*/, ::thingspect::api::TestAlarmResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TestAlarm(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateRule() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::thingspect::api::CreateRuleRequest, ::thingspect::api::Rule>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::thingspect::api::CreateRuleRequest, ::thingspect::api::Rule>* streamer) {
                       return this->StreamedCreateRule(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::CreateRuleRequest* /*request*/, ::thingspect::api::Rule* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateRule(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::thingspect::api::CreateRuleRequest,::thingspect::api::Rule>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateAlarm() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::thingspect::api::CreateAlarmRequest, ::thingspect::api::Alarm>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::thingspect::api::CreateAlarmRequest, ::thingspect::api::Alarm>* streamer) {
                       return this->StreamedCreateAlarm(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::CreateAlarmRequest* /*request*/, ::thingspect::api::Alarm* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateAlarm(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::thingspect::api::CreateAlarmRequest,::thingspect::api::Alarm>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRule() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::thingspect::api::GetRuleRequest, ::thingspect::api::Rule>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::thingspect::api::GetRuleRequest, ::thingspect::api::Rule>* streamer) {
                       return this->StreamedGetRule(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::GetRuleRequest* /*request*/, ::thingspect::api::Rule* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRule(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::thingspect::api::GetRuleRequest,::thingspect::api::Rule>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAlarm() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::thingspect::api::GetAlarmRequest, ::thingspect::api::Alarm>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::thingspect::api::GetAlarmRequest, ::thingspect::api::Alarm>* streamer) {
                       return this->StreamedGetAlarm(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::GetAlarmRequest* /*request*/, ::thingspect::api::Alarm* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAlarm(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::thingspect::api::GetAlarmRequest,::thingspect::api::Alarm>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateRule() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::thingspect::api::UpdateRuleRequest, ::thingspect::api::Rule>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::thingspect::api::UpdateRuleRequest, ::thingspect::api::Rule>* streamer) {
                       return this->StreamedUpdateRule(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::UpdateRuleRequest* /*request*/, ::thingspect::api::Rule* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateRule(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::thingspect::api::UpdateRuleRequest,::thingspect::api::Rule>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateAlarm() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::thingspect::api::UpdateAlarmRequest, ::thingspect::api::Alarm>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::thingspect::api::UpdateAlarmRequest, ::thingspect::api::Alarm>* streamer) {
                       return this->StreamedUpdateAlarm(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::UpdateAlarmRequest* /*request*/, ::thingspect::api::Alarm* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateAlarm(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::thingspect::api::UpdateAlarmRequest,::thingspect::api::Alarm>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteRule() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::thingspect::api::DeleteRuleRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::thingspect::api::DeleteRuleRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedDeleteRule(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::DeleteRuleRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteRule(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::thingspect::api::DeleteRuleRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteAlarm() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::thingspect::api::DeleteAlarmRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::thingspect::api::DeleteAlarmRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedDeleteAlarm(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::DeleteAlarmRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteAlarm(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::thingspect::api::DeleteAlarmRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListRules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListRules() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::thingspect::api::ListRulesRequest, ::thingspect::api::ListRulesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::thingspect::api::ListRulesRequest, ::thingspect::api::ListRulesResponse>* streamer) {
                       return this->StreamedListRules(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListRules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListRules(::grpc::ServerContext* /*context*/, const ::thingspect::api::ListRulesRequest* /*request*/, ::thingspect::api::ListRulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListRules(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::thingspect::api::ListRulesRequest,::thingspect::api::ListRulesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListAlarms : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListAlarms() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::thingspect::api::ListAlarmsRequest, ::thingspect::api::ListAlarmsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::thingspect::api::ListAlarmsRequest, ::thingspect::api::ListAlarmsResponse>* streamer) {
                       return this->StreamedListAlarms(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListAlarms() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListAlarms(::grpc::ServerContext* /*context*/, const ::thingspect::api::ListAlarmsRequest* /*request*/, ::thingspect::api::ListAlarmsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListAlarms(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::thingspect::api::ListAlarmsRequest,::thingspect::api::ListAlarmsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TestRule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TestRule() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::thingspect::api::TestRuleRequest, ::thingspect::api::TestRuleResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::thingspect::api::TestRuleRequest, ::thingspect::api::TestRuleResponse>* streamer) {
                       return this->StreamedTestRule(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TestRule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TestRule(::grpc::ServerContext* /*context*/, const ::thingspect::api::TestRuleRequest* /*request*/, ::thingspect::api::TestRuleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTestRule(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::thingspect::api::TestRuleRequest,::thingspect::api::TestRuleResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TestAlarm : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TestAlarm() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::thingspect::api::TestAlarmRequest, ::thingspect::api::TestAlarmResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::thingspect::api::TestAlarmRequest, ::thingspect::api::TestAlarmResponse>* streamer) {
                       return this->StreamedTestAlarm(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TestAlarm() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TestAlarm(::grpc::ServerContext* /*context*/, const ::thingspect::api::TestAlarmRequest* /*request*/, ::thingspect::api::TestAlarmResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTestAlarm(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::thingspect::api::TestAlarmRequest,::thingspect::api::TestAlarmResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CreateRule<WithStreamedUnaryMethod_CreateAlarm<WithStreamedUnaryMethod_GetRule<WithStreamedUnaryMethod_GetAlarm<WithStreamedUnaryMethod_UpdateRule<WithStreamedUnaryMethod_UpdateAlarm<WithStreamedUnaryMethod_DeleteRule<WithStreamedUnaryMethod_DeleteAlarm<WithStreamedUnaryMethod_ListRules<WithStreamedUnaryMethod_ListAlarms<WithStreamedUnaryMethod_TestRule<WithStreamedUnaryMethod_TestAlarm<Service > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_CreateRule<WithStreamedUnaryMethod_CreateAlarm<WithStreamedUnaryMethod_GetRule<WithStreamedUnaryMethod_GetAlarm<WithStreamedUnaryMethod_UpdateRule<WithStreamedUnaryMethod_UpdateAlarm<WithStreamedUnaryMethod_DeleteRule<WithStreamedUnaryMethod_DeleteAlarm<WithStreamedUnaryMethod_ListRules<WithStreamedUnaryMethod_ListAlarms<WithStreamedUnaryMethod_TestRule<WithStreamedUnaryMethod_TestAlarm<Service > > > > > > > > > > > > StreamedService;
};

}  // namespace api
}  // namespace thingspect


#endif  // GRPC_api_2fthingspect_5frule_5falarm_2eproto__INCLUDED
